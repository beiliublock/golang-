## 错误处理
1. 回顾：
   <br/>上次我们一起学习了常见的几种控制语句，了解到range的赋值只有一次，其后都是它的副本；switch语句和case子
   语句的结果值的类型要一致，而且子语句要具有唯一性。
2. 前导：
   <br/>在前面我们也已尽不止一次接触到Go语言的错误处理了，例如：error类型的变量，errors包中的New函数，今天我们
   一起来详细学习一下Go语言错误处理的相关知识。

   我们说过,error类型其实是一个接口类型，也是一个Go语言的内建模型。在这个接口类型的声明中包含了一个方法Error。
   这个方法不接受任何参数，但是会返回一个string类型的结果。它的作用是返回错误信息的字符串表示形式。我们使用error
   类型的方式通常是，在函数声明的结果列表的最后，声明一个该类型的结果，同时在调用这个函数之后，先判断它返回的最后
   一个值是否“不为nil”。如果这个值“不为nil”，那么就进入错误处理流程，否则就继续进行正常的流程。可以参考demo1.go
   的代码

        package main

        import (
        	"errors"
        	"fmt"
        )

        func echo(request string) (response string, err error) {
        	if request == "" {
        		err = errors.New("empty request")
        		return
        	}
        	response = fmt.Sprintf("echo: %s", request)
        	return
        }

        func main() {
        	for _, req := range []string{"", "hello!"} {
        		fmt.Printf("request: %s\n", req)
        		resp, err := echo(req)
        		if err != nil {
        			fmt.Printf("error: %s\n", err)
        			continue
        		}
        		fmt.Printf("response: %s\n", resp)
        	}
        }
   这里值得注意的地方有两个。第一，在echo函数和main函数中，我们都是用了卫述语句。在前面讲函数用法的时候也提到过卫述语句。
   简单的说，它就算被用来检查后续操作的前置条件并进行相应处理的语句。对于echo函数来说，它进行常规操作的前提是：传入的参数
   值一定要符合要求。而对于调用echo函数的程序来说，进行后续操作的前提就是echo函数的执行不能出错。

   再来说一下第二个值得注意的地方。我在生成error类型的时候用到了errors.New函数。这是一种最基本的生成错误值的方式。我们调用
   它的时候传入一个由字符串代表的错误信息，他会返回给我们一个包含了这个错误信息的error类型值。该值的静态类型当然是error，而
   动态类型则是一个在errors包中的，包级私有的类型*errorString。显然，errorString类型拥有的一个指针方法实现了error接口中的
   Error方法。这个方法被调用后，会原封不动的返回之前传入的错误信息。实际上，error类型值的Error方法就相当于其他类型值的String
   方法。

   我们已经知道，通过调用fmt.Printf函数，并给定占位符就可以打印出某个值的字符串表示形式。对于其他类型的值来说，只要我们能为这个
   类型编写一个String方法，就可以自定义它的字符串表示形式。而对于error类型值，它的字符串表示方式则取决于它的Error方法。在上述
   情况下，fmt.Printf函数如果发现被打印的值是一个error类型的值，那么就会去调用它的Error方法。fmt包中的这类打印函数其实都是这么做
   的。顺便提一句，当我们想通过模板化的方式生成错误信息，并得到错误值时，可以使用fmt.Errorf函数。该函数所作的其实就算先调用
   fmt.Sprintf函数，得到确切的错误信息；再调用errors.New函数，得到包含错误信息的error类型值，最后返回该值。

### Q：对于具体错误的判断，Go语言中都有哪些惯用法？
由于error是一个接口类型，所以即使同为error类型的错误值，它们的实际类型也可能不同。这个问题还可以换一种问法，即：怎样判断一个错误
值具体代表的是哪一类错误？

**典型回答**：
1. 对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch语句来判断
2. 对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断
3. 对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断

**问题解析**：
1. 类型在已知范围的错误值其实是最容易分辨的。就拿os包中的几个代表错误的类型`os.PathError、os.LinkError、os.SyscallError和os/exec.Error`
   来说，它们的指针类型都是error接口的实现类型，同时它们也都包含了一个名叫Err，类型为error接口类型的代表潜在错误的字段。如果我们得到一个
   error类型的值，并且知道该值的实际类型肯定是它们中的某一个，那么就可以用类型switch语句去做判断。例如：

        func underlyingError(err error) error {
            switch err := err.(type) {
                case *os.PathError: //由于指针类型包含所有方法所以使用指针类型
                    return err.Err
                case *os.LinkError:
                    return err.Err
                case *os.SyscallError:
                    return err.Err
                case *exec.Error:
                    return err.Err
            }
            return err
        }
   函数underlyingError的作用是：获取和返回已知的操作系统相关错误的潜在错误值。其中的类型switch语句中有若干子case子句，分别对应了上述几个错误
   类型。当它们被选中时，都会把函数参数err的Err字段作为结果值返回。如果它们都未被选中，那么该函数就会把参数值作为结果返回，即放弃获取潜在错误值。

   只要类型不同，我们就可以如此分辨。但是在错误值类型相同的情况下，这些手段就无能为力了。在Go语言的标准库中也有不少以相同方式创建的同类型的错误
   值。我们还拿os包来说，其中不少的错误值都是通过调用errors.New函数来初始化的，比如：os.ErrClosed、Os.ErrInvalid以及os.ErrPermission等等。注意，
   与前面讲到的那些错误类型不同，这几个都是已经定义好的、确切的错误值。os包中的代码有时候会把它们当作潜在错误值，封装进前面那些错误类型的值中。

   如果我们在操作文件系统的时候得到了一个错误值，并且知道该值的潜在错误值肯定是上述值中的某一个，那么就可以用普通的switch语句去做判读，当然了，用
   if语句和判等操作符也可以的。例如：

        printError := func(i int,err error) {
            if err == nil {
                fmt.Println("nil error")
                return
            }
            err = underlyingError(err)
            switch err {
            case os.ErrClosed:
                fmt.Printf("error(closed)[%d]:%s\n",i,err)
            case os.ErrInvalid:
                fmt.Printf("error(invalid)[%d]:%s\n",i,err)
            case os.ErrPermission:
                fmt.Printf("error(permission)[%d]:5s\n",i,err)
            }
        }
   这个由printError变量代表的函数会接受一个error类型的参数值。该值总会代表某个文件操作相关的错误，这是我故意的以不正确的方式操作文件后得到的。虽然我
   不知道这些错误值的类型的范围，但却知道它们或它们的潜在错误值一定是某个已经在os包中定义的值。所以。我先用underlyingError函数得到它们的潜在错误值，
   当然也可能只得到原错误值而已。然后，我用switch语句对错误值进行判等操作，三个case子句分别对应我刚刚提到的那三个已存在于os包中的错误值。如此一来，
   就能分辨出具体错误了。

   对于上面这两种情况，我们都有明确的方式去解决。但是，如果我们对一个错误值可能代表的含义知之甚少，那么就只能通过它拥有的错误信息去做判断了。好在我们
   总是能通过错误值的Error方法，拿到它的错误信息。其实os包中就有做这种判断的函数，比如：os.IsExist、os.IsNotExist和os.IsPermission。可以参考demo2.go
   中的代码。

#### 知识扩展
##### 问题1：怎样根据实际情况给予恰当的错误值？
我们已经知道，构建错误值体系的基本方法有两种，即：创建立体的错误类型体系和创建扁平的错误值列表。

+ 先说错误类型体系。由于在Go语言实现接口类型是非侵入式的，所以我们可以做得很灵活。比如，在标准库的net代码包种，有一个名为Error的接口类型。它算是内建接口
  类型error的一个扩展接口，因为error是net.Error的嵌入接口。net.Error接口除了拥有error接口的Error方法之外，还有两个自己声明的方法：Timeout和Temporary。
  net包中有很多错误类型都实现了net.Error接口，比如：
    1. *net.OpError
    2. *net.AddrError
    3. net.UnknownNetworkError等等。

  我们可以把这些错误类型想象成一棵树，内建接口error就是树的根，而net.Error接口就是根上延伸的第一级非叶子节点。同时，也可以把这看作是一种多层分类的手段。当
  net包的使用者拿到了一个错误值的时候，可以先判断它是否是net.Error类型的，也就是说该值是否代表了一个网络相关的错误。如果是，那么我们还可以再进一步判断它的
  类型是哪一个更具体地错误类型，这样就能知道这个网络相关地错误具体是由于操作不当引起地，还是因为网络地址问题引起地，又或者是由于网络协议不正确引起的。

  同时这些代码还可能会把一个*net.AddrError或net.UnknownNetWorkError类型的值赋给该错误值的Err字段，以表明导致这个错误的潜在原因。如果，此处的潜在错误值的
  Err字段也有非nil的值，那么将会指明更深层次的错误原因。如此一级又一级就像链条一样最终会指向问题的根源。把以上这些内容总结成一句话就是，用类型建立起树形
  结构的错误体系，用统一字段建立起可追根溯源的链式错误关联。这是Go语言标准库给予我们的优秀范本，非常有借鉴意义。不过要注意，如果你不想让包外代码改动你返回
  的错误值的话，一定要小写其中字段的名称首字母。你可以通过暴露某些方法让包外代码有进一步获取错误信息的权限，比如编写一个可以返回包级私有的err字段的公开方法
  Err。

+ 相比于立体的错误类型体系，扁平的错误值列表就要简单得多了。当我们只是想预先创建一些代表已知错误的错误值的时候，用这种扁平化的方式就很恰当了。不过由于error是
  接口类型，所以通过errors.New函数生成的错误值只能被赋予给变量，而不能赋给常量，又由于这些代表错误的变量需要给包外代码使用，所以其访问权限只能是公开的。这就
  带来了一个问题，如果有恶意代码改变了这些公开变量的值，那么程序的功能必然会受到影响。因为在这种情况下我们往往会通过判等操作来判断拿到的错误值具体是哪一个错误，
  如果这些公开变量的值被改动了，那么相应的判等操作的结果也会随之改变。

  这里有两个解决方案：
    1. 第一个方案是，先私有化此类变量，也就是说，让它们的名称首字母变成小写，然后编写公开的用于获取错误值以及用于判等错误值的函数。比如，对于错误值os.ErrClosed，
       先改写它的名称，让其变成os.errClosed，然后再编写ErrClosed函数和IsErrClosed函数。当然了，这不是说让你去改动标准库中已有的代码，这样做的危害会很大，甚至是
       致命的。我只能说，对于你可控的代码，最好还是要尽量收紧访问权限。
    2. 再来说第二个方案，此方案存在于syscall包中。该包中有一个类型叫做Errno，该类型代表了系统调用时可能发生的底层错误。这个错误类型是error接口的实现类型，同时
       也是对内建类型uintptr的在定义类型。由于uintptr可以作为常量的类型，所以syscall.Errno自然也可以。syscall包中声明有大量的Errno类型的常量，每个常量都对应一种
       系统调用错误。syscall包外的代码可以拿这些代表错误的常量，但却无法改变它们。我们可以仿照这种声明方式来构建我们自己的错误列表，这样就可以保证错误值的只读特性了。
       好了，总之，扁平的错误值列表虽然相对简单，但是一定要知道其中的隐患以及有效的解决方案是什么。

#### 总结
今天，我们从两个视角总结了错误类型、错误值的处理技巧和设计方式。我们先一起来看一下Go语言中处理错误的最基本方式，这涉及了函数结果列表设计、errors.New函数、卫述语句
以及使用打印函数输出错误值。

接下来，我提出了第一个问题是关于错误判断的。对于一个错误值来说，我们可以获取它的类型、值以及它携带的错误信息。如果我们可以确定其类型范围或者值的范围，那么就可以使用
一些明确的手段获知具体的错误种类。否则，我们就只能通过匹配其携带的错误信息来大致区分它们的种类。由于底层系统给予我们的错误信息还是很有规律可循的，所以用这种方式去判断
效果还比较显著。但是第三方程序给出的错误信息很可能就没有那么规整了，这种情况下靠错误信息去辨识种类就会比较困难。

有了以上的阐释，当吧视角从使用者换位到建造者，我们往往就会去自觉的仔细思考程序错误体系的设计了。在这里提出了两个在Go语言标准库中使用很广泛的方案，即：**立体的错误类型
体系和扁平的错误值列表**。之所以说错误体系是立体的，是因为从整体上看它往往呈现出树形的结构。通过间的嵌套以及接口的实现，我们就可以构建出一棵错误类型树。通过这棵树，使用
者就可以一步步的确定错误值的种类了。另外，为了追根溯源的需要，我们还可以在错误类型中，统一安放一个可以代表潜在错误的字段。这叫做链式的错误关联，可以帮助使用者找到错误的根
源。

相比之下，错误值列表就比较简单了。它其实就是若干个名称不同但类型相同的错误值集合。不过需要注意的是，如果它们是公开的，那就应该尽量让它们成为常量而不是变量，或者编写私有的
错误值以及公开的获取和判等函数，否则就很难避免恶意的篡改。

这其实是 **“最小化访问权限”** 这个程序设计原则的一个具体体现。无论怎样设计程序错误体系，我们都应该把这一点考虑在内。


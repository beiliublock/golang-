## 结构体及其方法的使用法门
1. 回顾：
   <br/>我们上次一起学习了函数的几种常用使用方式，了解了什么是高阶函数和闭包函数。
2. 前导：结构体类型基础知识
   <br/>我们都知道，结构体类型表示的是实实在在的数据结构，一个结构体可以包含若干个字段，也可以不包含任何字段。
   每个字段通常都需要有确切的名字和类型。当然空结构体也并不是没有意义的，我们可以为其关联一些方法。

   函数是独立的程序实体。我们可以声明有名字的函数，也可以声明匿名函数，还可以把它们当作普通的值传递。
   我们把具有相同签名的函数抽象成独立的函数类型，以作为一组输入、输出(或者说一类逻辑组件)的代表。方法
   却不同，它需要有名字，不能被当作值来看待，最重要的是，它必须隶属于某一个类型。方法所属的类型通过其
   中的接收者(receiver)声明体现出来。

   接收者声明就是在关键字func和方法名之间的圆括号包裹起来的内容，其中必须包含确切的名称和类型字面量。
   **接收者的类型其实就是当前方法所属的类型，而接收者的名称，则用于在当前方法中引用它所属的类型
   的当前值**，举一个例子看一下：

        //AnimalCategory 代表动物分类学中的基本分类法
        type AnimalCategory struct {
            kingdom string //界
            phylum  string //门
            class   string //纲
            order   string //目
            family  string //科
            genus   string //属
            species string //种
        }
        //结构体的方法
        func (ac AnimalCategory) String() string {
            return fmt.Sprintf("%s%s%s%s%s%s%s",
                    ac.kingdom,ac.phylum,ac.class,ac.order,ac.family,ac.genus,ac.species)
        }
   结构体类型AnimalCategory代表了动物的基本分类法，其中7个string类型的字段，分别表示各个等级的分类。

   下面有个叫String的方法，从它的接收者声明可以看出它隶属于AnimalCategory类型。通过该方法的接收者名称
   ac，我们可以在其中引用到当前的任何一个字段，或者调用到当前值的任何一个方法（也包括String方法自己）。
   这个String方法的功能是提供当前值的字符串表示形式，其中的各个等级分类会按照从大到小的顺序排列。使用
   时，我们可以这样表示：

        category := AnimalCategory{species:"cat"}
        fmt.Printf("The animal category:%s\n",category)
   在Go语言中，我们可以通过为一个类型编写名为String的方法，来定义该类型的字符串表示形式。这个String
   方法不需要任何参数声明，但需要有一个string类型的结果声明。正因为如此，我在调用fmt.Printf函数时，使用
   占位符%s和category值本身就可以打印出后者的字符串表示形式，而无需显示的调用它的String方法。
   >方法隶属于的类型其实并不局限于结构体类型，但必须是某个自定义的数据类型，并且不能是任何接口类型。
   <br/><br/>一个数据类型关联的所有方法，共同组成了该类型的方法集合。同一个方法集合中的方法不能出现
   重名。并且，**如果它们所属的是一个结构体类型，那么它们的名称与该类型中任何字段的名称也不能重复**。
   <br/><br/>我们可以把结构体类型中的一个字段看作是它的一个属性或者一项数据，再把隶属于它的一个方法看作
   是附加在其中数据之上的一个能力或者一项操作。将属性及其能力封装在一起，是面向对象编程(object-oriented programming)
   的一个主要原则。
   <br/><br/>Go语言摄取了面向对象编程中的很多优秀特性，同时也推荐这种封装的做法。从这方面看，Go语言其实
   是支持面向对象编程的，但它选择摒弃了一些在实际运用过程中容易引起程序开发者困惑的特性和规则。

   我们重新把目光放到结构体上，我们来看下面的代码：

        type Animal struct {
            scientificName  string //学名
            AnimalCategory         //动物学基本分类
        }

### Q：Animal类型中的字段声明AnimalCategory代表了什么？
更宽泛的讲，如果结构体类型的某个字段声明中只有一个类型名，那么该字段代表了什么？

A：字段声明AnimalCategory代表了Animal类型的一个嵌入字段。Go语言规范规定，如果一个字段的声明中只有
字段的类型名而没有字段的名称，那么它就是一个嵌入字段，也可以被成为匿名字段。我们可以通过此类型变量
的名称后面跟“.”，再后跟嵌入字段的方式引用到该字段。也就是说，嵌入字段的类型既是类型也是名称。同时，
嵌入字段的方法集合会被无条件的合并进被嵌套的方法集合中。

**那如果也为Animal类型编写一个String方法呢？**
<br/>这时，我们说，嵌入字段AnimalCategory的String方法被“屏蔽”了。注意，只要名称相同，无论这两个方法的
签名是否一致，被嵌入类型的方法都会“屏蔽”掉嵌入字段的同名方法。类似的，如果这两个结构体类型里存在同样的
字段，那么嵌入字段中的那个字段一定会被“屏蔽”。这与我们在前面讲过的，可重名变量之间可能存在的“屏蔽”现象
很相似。正因为嵌入字段的字段和方法都可以“嫁接”到被嵌入类型上，所以即使在两个同名的成员一个是字段，另一个
是方法的情况下，这种“屏蔽”现象依然会存在。

不过，即使被屏蔽了，我们仍然可以通过链式的选择表达式，选择嵌入字段的字段或方法。

如果处于同一个层级的多个嵌入字段拥有同名的字段或方法，那么从被嵌入类型的值那里，选择此名称的时候就会引发一个
编译错误，因为编译器无法确定被选择的成员到底是哪一个，可以参考看以下demo1.go中的代码

#### 知识扩展
**问题1：Go语言是用嵌入字段实现了继承吗？**
<br/>先强调一下，Go语言中根本没有继承的概念，它所做的是通过嵌入字段的方式实现了类型之间的组合。这样做的具体原因
和理念请见Go语言官网的FAQ中的[Why is there no type inheritance?](https://golang.org/doc/faq#inheritance)

简单来说，面向对象编程中的继承，其实是通过牺牲一定的代码简洁性来换取可扩展性，而这种可扩展性是通过侵入的方式来
实现的。类型之间的组合采用的是非声明的方式，我们不需要显示的声明某个类型实现了某个接口，或者一个类型继承了另一个
类型。同时，类型组合也是非侵入式的，它不会破坏类型或加重类型之间的耦合。

我们要做的只是把类型当作字段嵌入进来，然后坐享其成功的使用嵌入字段所拥有的一切。如果嵌入字段有哪里不合心意，我们
还可以用“包装”或“屏蔽”的方式去调整和优化。另外，类型间的组合也是灵活的，我们总是可以通过嵌入字段的方式把一个
类型的属性和能力“嫁接”给另一个类型。

这时候，被嵌入类型也就自然而然地实现了嵌入字段所实现地接口。再者，组合要比继承更加简洁和清晰，Go语言可以轻而易举
地通过嵌入多个字段来实现功能强大地类型，却不会有多继承那样复杂地层次结构和可观地管理成本。

同样，接口和接口之间也可以组合。甚至在Go语言中，接口类型之间地组合更常见，以此来扩展接口定义地行为或者标记
接口地特征。

**问题2：值方法和指针方法都是什么意思，有什么区别？**
<br/>我们都知道，方法地接收者类型必须是某个自定义地数据类型，而不能是接口类型或者接口地指针类型。所谓地
值方法，就是接收者类型是非指针地自定义数据类型地方法。

那么什么叫指针类型呢？这里同样贴一段代码：

    func (cat *Cat) SetName(name string) {
        cat.name = name
    }
方法SetName的接收者类型是*Cat。Cat左边再加个*代表的就是Cat类型的指针类型，这时Cat可以被叫做*Cat的基本类型。
可以认为这种指针类型的值表示的是指向某个基本类型值的指针。

我们可以通过把取值操作符*放在这样一个指针值的左边来组成一个取值表达式，以获取该指针值指向的基本类型值，也可以
通过把取址操作符&放在一个可寻址的基本类型值的左边来组成一个取址表达式，以获取该基本类型值的指针。所谓的指针
方法，就是接收者类型是上述指针类型的方法。

那么值方法和指针方法之间有什么不同点呢？
1. 值方法的接收者是该方法所属的那个类型值的一个副本。而指针方法的接收者，是该方法所属的那个基本类型值
   的指针值的一个副本
2. 一个自定义数据类型的方法集合中仅会包含它的所有值方法，而该类型的指针类型的方法集合却囊括了前者的所
   有方法，包括所有值方法和所有指针方法
3. 严格来讲，我们再这样的基本类型的值上只能调用它的值方法。但是，Go语言会适时的为我们进行自动的转译，
   使得我们在这样的值上也能调用到它的指针方法
4. 在后面会了解到，一个类型方法集合中有哪些方法与它能实现哪些接口类型是息息相关的。如果一个基本类型和它
   的指针类型的方法集合是不同的，那么它们具体实现的接口类型的数量也就会有差异，除非这两个数量都是零。

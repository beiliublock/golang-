## 程序实体
**Go语言中的程序实体包括常量、变量、函数、结构体和接口。** Go语言是静态类型的编辑语言，
所以我们再声明变量或常量的时候，都需要指定它们的类型，或者给予足够的信息，这样才可以让Go
语言能够推导出它们的类型
>在Go语言中，变量的类型可以是其预定义的那些类型，也可以是程序自定义的函数，结构体或接口。
常量的合法类型不多，只能是那些Go语言预定义的基本类型。

### Q：声明变量有几种方式
我们先看一段代码

    package main

    import (
    	"flag"
    	"fmt"
    	"os"
    )

    //go run demo1.go -name BaoZhiHao
    //output:Hello,BaoZhiHao
    func main11() {
    	var name string  //指定类型声明
    	cmd := flag.NewFlagSet("proEntity",flag.ExitOnError)
    	cmd.StringVar(&name,"name","everyone","The greeting object")
    	cmd.Parse(os.Args[1:])//注意os.Args的第一个元素是程序名，所以我们忽略
    	fmt.Printf("Hello,%v",name)
    }

    func main()  {
    	cmd := flag.NewFlagSet("proEntity",flag.ExitOnError)
    	name := cmd.String("name", "everyone", "The greeting object")
    	//需要注意的是，这里不能直接使用*取出内容，不然无法解析，会一直输出默认值：everyone
    	//短变量声明，注意这种声明方式只能用于函数内部
    	cmd.Parse(os.Args[1:])
    	fmt.Printf("Hello,%v",*name)//注意flag.String输出的是地址，所以我们用*取出内容
    }
这是一个很简单的命令源码文件，我们把它命名为demo1.go。

<br/>**典型回答：**
   + 第一种方式：使用var指定类型声明
   + 第二种方式：使用`:=`进行短变量声明，使用了Go语言自身类型推断的能力
   >简单的说，类型推断是一种编程语言在编译期自动解释表达式类型的能力

#### 知识扩展
1. Go语言的类型推断可以带来哪些好处？
   <br/>1.在写代码时，可以帮我们节省敲击键盘的次数
   <br/>2.体现在我们写完代码之后的那些事上，如：代码重构，可以看一下demo2.go
   >我们通常把“不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现”的代码
   修改方式，叫做对该程序的重构。重构对象可以是一行代码、一个函数、一个功能模块，甚至
   一个软件系统。
   <br/>所以demo2实际上就是对demo2中“声明并赋值name变量那行代码”(10行)的重构

  + 小结：
     1. Go语言是静态类型的，所以一旦在初始化变量时确定了它的类型，之后就不可能再改变。
     这就避免了在后面维护程序时的一些问题。另外，请记住，这种类型的确定是在编译期完成的，
     因此不会对程序的运行效率产生任何影响。这是相较于动态类型的编程语言的优势
     2. Go语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会
     给代码的维护带来额外的负担(实际上，它恰恰可以避免散弹式的代码修改)，更不会损失程序的
     运行效率

2. 变量的重声明是什么意思？
  <br/>这涉及了短变量声明。通过使用它，我们可以对同一个代码块中的变量进行重声明
   > 在Go语言中，代码块一般就是由一个花括号{}括起来的区，里面可以包含表达式和语句。
   一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序
   实体的访问权限的控制。对“高内聚，低耦合”这种程序设计思想的实践，恰恰可以从这里
   开始。当然在Go语言中也有例外的情况，我们以后会讲到
  + 变量重声明就是对已经声明过的变量再次声明。**变量重声明的前提条件**：
     1. 由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其
     原本的类型相同，否则会产生编译错误
     2. 变量的重声明只可能发生在某一段代码块中。如果与当前的变量重名的是外层代码块中
     的变量，那么就是另外一种含义了
     3. 变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处
     声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码
     块中的任何变量有重名
     4. 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说
     对其中的旧变量进行了重声明
  + 小结：
    <br/>这样来看，变量重声明其实就算是一个语法糖。它允许我们在使用短变量声明时不用理会
    被赋值的多个变量中是否包含旧变量。

        代码示例：
        err := errors.New("This is a error")
        n,err := io.WriteString(os.Stdout,"Hello everyone!\n") //这里对err进行了重声明

### Q：如果一个变量与外层代码块中的变量重名会出现什么状况？
我们来看一段代码

    package main
    import "fmt"
    var block = "package"  //main包代表的代码块
    func main() {
        block := "function"  //main函数代表的代码块
        {
            block := "inner"  //在main函数中的一个用花括号包起来的代码块
            fmt.Printf("The block is %s\n",block)
        }
        fmt.Printf("The block is %s",block)
    }
    //Output:
    //The block is inner
    //The block is function
这个命令源码文件中有4个代码块，分别为：全域代码块，main包代表的代码块、main函数代表的代码块，
以及在main函数中的一个用花括号包起来的代码块。

+ 问题解析：
    1. 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码
    块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块
    2. 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接
    包含当前代码块的那个代码块开始，一层一层的查找(从内层(当前代码块)到外层)
    3. 一般情况下，程序会一直查到当前代码包代表的代码块。如果任然找不到，那么Go语言的编译器
    就会报错
    4. 如果我们在当前源码文件中导入了其他代码包，那么引用其中的程序实体时，是需要以限定符为
    前缀的。所以程序在找代表变量未加限定符的名字(即标识符)的时候，是不会去被导入的代码包中查
    找的
    >但是有个特殊情况，如果我们把代码包导入语句写出`import . XXX`的形式(注意中间的那个".")，
    那么就会让这个"XXX"包中公开的程序实体，被当前源码文件中的代码，视为当前代码包中的程序实体
    <br/><br/>比如，如果有代码包导入语句`import ."fmt"`，那么我们在当前源码文件中引用`fmt.Printf`
    函数的时候直接用Printf就可以了。在这个特殊情况下，程序在查找当前源码文件后会先去查用这个方式
    导入的那些代码包

+ 小结：
  + 从作用域的角度来说，虽然通过var block = "package"声明的变量作用域是整个main代码包，但是
  在main函数中，它却被那两个同名的变量“屏蔽”了
  + 相似的，虽然main函数首先声明的block的作用域，是整个main函数，但是在最内层的那个代码块中，
  它却是不可能被引用到的。反过来讲，最内层代码块中的block也不可能被该块之外的代码引用到，这也是
  打印内容的第二行是“The block is function”的另一半原因

#### 知识扩展
**不同代码块中的重名变量与变量重声明中的变量区别到底在哪里？**
<br/>**为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”**。注意，在同一个代码
块中不允许出现重名的变量，这违背了Go语言的语法。关于这两者的表象和机理，我们已经讨论得足够充分
了，下面我们列出几条区别？
   1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任
   何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识
   符代表的变量
   2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有
   多个的
   3. **不论对变量重声明多少次，其类型必须始终一致**，具体遵从它第一次被声明时给定的类型。**而
   可重名变量之间不存在类似的限制，它们的类型可以是任意的**
   4. 如果可重名变量所在的代码块之间，存在直接或间接地嵌套关系，那么它们之间一定会存在“屏蔽”
   的现象。但是这种现象绝对不会在变量重声明的场景下出现
   5. 再次强调一下，变量重声明的前提是使用短变量声明的，且重声明时变量一定要变多(不然也无法使用
   短变量声明)

<br/>我们再细看一下第3点，既然可重名变量的类型可以是任意的，那么当它们之间存在“屏蔽”时就更需要注意
了，不同类型的值大都有着不同的特性和用法，但是值得庆幸的是，编译器会发现其中的问题。当是当可重名变量
的值被转换成某个接口类型值，或者它们的类型本身就是接口类型的时候，严格的类型检查就很有必要了，我们在
后面会讲到。

### Q：怎样判断一个变量的类型？
一样的，我们先来看一段代码：

    package main
    import "fmt"
    var container = []string{"zero","one","two"}
    func main() {
        container := map[int]string{0:"zero",1:"one",2:"two"}
        fmt.Printf("The element is %q\n",container[1])
    }
那么，怎样在打印其中元素之前，正确判断变量container的类型呢？可以看一下demo3.go中的代码

1. 典型回答：使用类“类型断言”表达式

       value,ok := interface{}(container).([]string)
   这里有一条赋值语句，在赋值号的右边，是一个类型断言表达式。
   + 它包括了用来把container变量的值转换问空接口值的interface{}(container),以及一个用于
   判断前者的类型是否为切片类型[]string的`.([]string)`。
   + 这个表达式的结果可以被赋给两个变量，在这里由value和ok代表。变量ok是布尔(bool)类型的，
   它将代表类型判断的结果，true或者false。如果是true，那么被判断的值将会被自动转换为[]string
   类型的值，并赋给变量value，否则value将被赋予nil(即“空”)。顺便提一下，这里的ok也可以没有，
   直接将类型断言的结果赋给变量value。但是这样会引发程序的恐慌(panic)
2. 问题解析
   1. 正式说明一下，类型断言表达式的语法形式是`x.(T)`。其中x代表要被判断类型的值，这个值必须
   是接口类型的，不过具体是哪个接口类型是无所谓的
   2. 所以，我们必须先将container变量显示的转换成接口类型，`interface{}(container)`；在Go语言
   中`interface{}`代表空接口，任何类型都是它的实现类。我们以后会讲接口及其实现类的问题。现在，
   我们只要知道，任何类型的值都可以很方便的被转换为空接口的值就可以了
   3. 我们可能会对这里的{}产生疑惑，为什么关键字interface的右边还要加上这个东西？
   >请记住，一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容
   的数据结构(或者说数据类型)。例如后面我们还会使用struct{}，它就代表了不包含任何字段和方法的、
   空的结构体类型，而空接口interface{}则代表了不包含任何方法定义的、空的接口类型
   4. 我们再向答案的最右边看，圆括号中[]string是一个类型字面量。所谓类型字面量就是用来表示数据
   本身的若干个字符

#### 知识扩展
  1. **类型转换规则中有哪些值得关注的地方**
    + **对于整数类型值，整数常量之间的类型转换，原则上只要源值在目标类型的表示范围就是合法的**；
    需要注意的是，当整数值的类型的有效范围由宽变窄时(int16->int8)，只需要在补码形式下截掉
    一定数量的高位二进制即可
    + **虽然直接把一个整数值转换为一个string类型值是可行的，但值得关注的是，被转换的整数值
    应该可以代表一个有效的Unicode代码点，否则转换的结果将会是`�`**；字符`�`的Unicode代码
    点是U+FFFD。它是Unicode标准定义的`Replacement Character`，专用于替换那些未知的、不被
    认可的以及无法展示的字符
    + **关于string类型与各种切片类型之间的互转**。首先我们要理解的是，一个值在从string类型向
    []byte类型转换时代表着以UTF-8编码的字符串会被拆分成零散、独立的字节。除了与ASCII编码兼容的那
    部分字符集，以UTF-8编码的某个单一字节是无法代表一个字符的

          比如，UTF8编码的三个字节\xe4、\xbd和\xa0合在一起才能代表字符'你'，而\xe5、\xa5、\xbd合在一起才能代表字符'好'
            string([]byte{'\xe4', '\xbd', '\xa0', '\xe5', '\xa5', '\xbd'}) // 你好
          其次，一个值从string类型向[]rune类型转换时代表着字符串会被拆分成一个个Unicode字符
            string([]rune{'\u4F60', '\u597D'}) // 你好

  2. **什么是别名类型？什么是潜在类型？**
     + 我们可以用关键字type声明自定义的各种类型。当然了，这些类型必须在go语言基本类型和高级类型的范畴
     之内。在它们之中，有一种被叫做“别名类型”的类型。我们可以这样声明它：

            type myString = string
            这条语句表示，Mystring是string类型的别名类型。顾名思义，别名类型于其源类型的区别恐怕只在名称上，它们是完全相同的
     + 潜在类型的含义是：某个类型在本质上是哪个类型，或者是哪个类型的集合

     ![](https://ww1.sinaimg.cn/large/007i4MEmgy1fytwlafnq1j30o10k3jxa.jpg)


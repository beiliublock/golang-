## 关于指针的有限操作
1. 回顾：
   <br/>前面我们一起学习了接口的相关操作，知道存储接口的是一个复杂的数据结构(iface)，它的实例包含两个指针：
   一个指向类型信息的指针，一个指向动态值的指针。赋给接口的值的副本只是这个复杂数据结构的一部分；同时接口的
   组合和结构体一样也是无侵入式的嵌入。我们在使用接口的时候应该尽量使用小接口和接口组合使得程序变得灵活和稳
   定。
2. 前导：
   <br/>在前面的文章中，我们已经多次提到“指针”了，不过，那时我们大多指的是指针类型及其对应的指针值，今天
   我们将深入了解一下指针的相关操作。我们先看一下以前的代码：

        type Dog struct {
            name string
        }

        func (dog *Dog) SetName(name string) {
            dog.name = name
        }
   对于基本类型Dog来说，*Dog就是它的指针类型。而对于一个Dog类型，值不为nil的变量dog，取址表达式&dog的结果就是
   该变量的值（也就是基本值）的指针值。如果一个方法的接收者是*Dog类型的，那么该方法就是基本类型Dog的指针方法。
   在这种情况下，这个方法的接收者实际上就是当前的基本值的指针值。我们可以通过指针值无缝的访问到基本值包含的任何
   字段，以及调用与之关联的任何方法。这应该就是我们在编写Go语言时，用的最频繁的“指针”了。

   从传统意义上说，指针是一个指向某个确切的内存地址的值。这个内存地址可以是任何数据或代码的起始地址，例如某个变量、
   某个字段或某个函数。

   我们刚刚只提到了其中的一种情况，在Go语言中还有其他几样东西可以代表“指针”。其中最贴近传统意义的当属`uintptr`
   类型了。该类型实际上就是一个数值类型，也是Go语言内建的数据类型之一。根据当前计算机的计算架构不同，它可以存储32
   位或64位的无符号整数，可以代表任何指针的位(bit)模式，也就是原始的内存地址。再来看看Go语言标准库中的unsafe包中
   的`Pointer`类型，这个类型也代表“指针”。`unsafe.Pointer`可以表示任何指向**可寻址的值的指针**，同时它也是前
   面提到的指针值和`uintptr`值之间的桥梁。也就是说，通过它，我们可以在这两种值之上进行双向的转换。这里有一个很关
   键的词——可寻址的(addressable)。在我们继续说unsafe.Pointer之前，需要先搞清楚`可寻址的`确切含义。

### Q：你能列举出Go语言中哪些值是不可寻址的吗？
**典型回答：**
+ 常量的值
+ 基本类型值的字面量
+ 算术操作的结果值
+ 对各种字面量的索引表达式和切片表达式的结果值。不过有一个例外，对切片字面量的索引结果值却是可寻址的
+ 对字符串变量的索引表达式和切片表达式的结果值
+ 对字典变量的索引表达式的结果值
+ 函数字面量和方法字面量，以及对它们的调用表达式的结果值
+ 结构体字面量的字段值，也就是对结构体字面量的表达式的结果值
+ 类型转换表达式的结果值
+ 类型断言表达式的结果值
+ 接收表达式的结果值

**问题解析：**
<br/>初看答案中的这些不可寻址的值似乎并没有什么规律。我们先来梳理一下，可以参考demo1.go中的代码来看，我
想这样应该理解起来更容易一些。

常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是**不可变的**。基本类型值的字面量也是一样，其
实它们本就可以被视为常量，只不过没有任何标识符可以代表它们罢了。

第一个关键字：不可变。由于Go语言中的字符串值也是不可变的，索引对于一个字符串类型的变量来说，基于它的索引或
切片的结果值也都是不可寻址的，因为计算拿到了这种值的内存地址也改变不了什么。算术操作的结果值属于一种**临时
结量**。我们把这种结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的。

第二个关键字：临时结果。这个关键字能被用来解释很多现象。我们可以把各种对值字面量施加的表达式的求值结果都看作
是临时结果。我们都知道，Go语言中的表达式有很多种，其中常见的包括以下几种：
+ 用于获得某个元素的索引表达式
+ 用于获得某个切片(片段)的切片表达式
+ 用于访问某个字段的选择表达式
+ 用于调用某个函数或方法的调用表达式
+ 用于转换值的类型的类型转换表达式
+ 用于判断值的类型的类型断言表达式
+ 向通道发送元素值或从通道那里接收元素值的接收表达式

一个需要特别注意的例外是，对切片字面量的索引结果值是可寻址的。因为不论怎样，每个切片值都会持有一个底层数组，而
这个底层数组中的每个元素值都是有一个确切的内存地址的，那么为什么对于切片字面量的切片结果值却不可寻址？因为切片
表达式总会返回一个新的切片值，而这个新的切片值在被赋给变量之前属于临时结果。

我们一值在说针对数组值、切片值或字典值的**字面量**的表达式会产生临时结果。如果针对的是数组类型或切片类型的**变
量**，那么索引或切片的结果值就不属于临时结果了，是可寻址的。这主要是因为变量的值本身就不是“临时的”。对此而言，
值字面量在还没有与任何变量（或者说任何标识符）绑定之前是没有落脚点的，我们无法以任何方式引用到它们。这样的值就是
“临时的”。

再说一个例外，我们通过对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，可是这样的值却是不可寻址的。原因
是，字典中的每个键-元素对的存储位置都可能变化(解决散列冲突)，而这种变化外界是无法感知的。我们都知道，字典中总会有若
干个哈希桶用于均匀的存储键-元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时的把其中的键-元素对搬运到对应
的新哈希桶中。在这种情况下，获取字典中任何元素值都是无意义的。也是**不安全的**。所以这样的值就应该是不可寻址的。

第三个关键字：不安全的。“不安全的”操作很可能会破坏程序的一致性，引发不可预知的错误，从而严重影响程序的功能和稳定性。

再来看函数。函数在Go语言中是一等公民，所以我们可以把代表函数或方法的字面量或标识符赋给某个变量、传给某个函数或从某个
函数传出。但是，这样的函数和方法都是不可寻址的。一个原因是函数就是代码，是不可变的。另一个原因是，拿到指向一段代码的
指针是不安全的。此外，对函数或方法的调用结果值也是不可寻址的，这是因为它们都属于临时结果。至于典型回答中最后列出的那
几种值，由于都是针对值字面量的某种表达式的结果值，所以都属于临时结果，不可寻址。

**总结：**
1. **不可变的**值不可寻址。常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量值都是如此。其实这样规定也
有安全性方面的考虑。
2. 绝大多数被视为**临时结果**的值都是不可寻址的。算术操作的结果值属于临时结果，针对值字面量的表达式结果也属于属于临
时结果。担有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但却是可寻址的。
3. 但是当我们把一个临时结果赋给了一个变量，那么它就是可寻址的了。如此一来，取得的指针指向的就是这个变量持有的那个值了。
4. 若拿到某值的指针可能会破外程序的一致性，那么就是**不安全的**，该值不可寻址。由于字面的内部机制，对字典的所有结果
值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。

#### 知识扩展
##### 问题1：不可寻址的值在使用上有哪些限制？
首当其冲的当然是无法使用取址操作符&获取它们的指针了。不过，对不可寻址的值施加取址操作都会使编译器报错，所以不用太担心，
只要记住在前面讲述的那几条规律，并在编码前注意以下就好了。我们来看下面这个小问题。我们依然以结构体Dog为例：

    func New(name string) Dog {
        return Dog{name}
    }
我们再为它编写一个函数New。这个函数会接受一个名为name的string类型的参数，并会用这个参数初始化一个Dog类型的值，最后返回
该值。我现在要问的是：如果我调用该函数，并且以链式的手法调用其结果值的指针方法SetName，那么可以达到预期的效果吗？

    New("little pig").SetName("monster")
我们知道调用New函数所得的结果属于临时结果，是不可寻址的。可是，那有怎样，别忘了我们在学习结构体及其方法的时候说过，我们
可以在一个基本类型的值上调用它的指针方法，这是因为Go语言会自动地帮我们转译。更具体地说，对于一个Dog类型地变量dog来说，调
用表达dog.SetName("monster")会被自动的转译为(&dog).SetName("monster")，即：先取dog的指针值，再在该指针值上调用SetName方
法。

发现问题了吗？由于New函数的调用结果是不可寻址的，所以无法对它进行取址操作符。因此，上边这行链式调用会让编译器报告两个错误，
一个是果，即：不能在New("little pig")的结果值上调用指针方法。一个是因，即：不能取得New("little pig")的地址。

除此之外，我们都知道，Go语言中的++和--并不属于操作符，而分别是自增语句和自减语句的重要组成部分。虽然Go语言规范中的语法定义是，
只要在++或--的左边添加一个表达式，就可以组成一个自增语句或自减语句，但是它还明确了一个很重要的限制，那就是这个表达式的结果值
必须是可寻址的，这就使得针对字面量的表达式几乎都无法被用在这里。不过这有一个例外，虽然对字典字面量和字典变量索引表达式的结果值
都是不可寻址的，但是这样的表达式却可以被用在自增语句和自减语句中。

与之类似的规则还有两个。一个是，在赋值语句中，赋值操作符左边的表达式的结果值必须是可寻址的，但是对字典的索引结果值也是可以的。
另一个是，在带有range子句的for语句中，在range关键字左边的表达式的结果值也都必须是可寻址的，不过对字典的索引结果值同样可以被用
在这里。以上这三条规则我们合并起来记忆就可以了。

##### 问题2：怎样通过unsafe.Pointer操作可寻址的值？
前边的基础知识很重要。不过现在让我们再次关注指针的用法。我说过，unsafe.Pointer是像*Dog类型的值这样的值这样的指针值和uintptr
值之间的桥梁，那么我们怎样利用unsafe.Pointer的中转和uintptr的底层操作来操纵像dog这样的值呢？

首先说明一下，这是一项黑科技，他可以绕过Go语言的编译器和其他工具的重重检查，并达到潜在内存修改数据的目的。不过要记住的是，这
并不是一种正常的编程手段，使用它会很危险，很有可能造成安全隐患。我们总是应该优先使用常规代码包中提供的API去编写程序，当然也可
以把像reflect以及go/ast这样的代码包作为备选项。作为上层应用的开发者，请谨慎的使用unsafe包中的任何程序实体。不过既然说到这里了
我们还是要来一探究竟，可以看一下下面的代码：

    dog := Dog{"little pig"}
    dogP := &dog
    dogPtr := uintptr(unsafe.Pointer(dogP))
我们先声明了一个Dog类型的变量dog，然后用取址操作符&，取出了它的指针值，并把它赋给了变量dogP。最后，我使用了两个类型转换，先把
dog转换成了一个unsafe.Pointer类型的值，然后紧接着又把后者转换成了一个uintptr的值，并把它赋给了变量dogPtr。这背后隐藏着一些转换
规则，如下：
1. 一个指针值（比如*Dog类型的值）可以被转换为一个unsafe.Pointer类型的值，反之亦然。
2. 一个uintptr类型的值也可以被转换为一个unsafe.Pointer类型的值，反之亦然。
3. 一个指针值无法被直接转换成一个uintptr类型的值，反过来也是如此。
<br/>所以，对于指针值和uintptr类型值之间的转换，必须使用unsafe.Pointer类型的值作为中转。那么，我们把指针值转换成uintptr类型的值
有什么意义吗？

       namePtr := dogPtr + unsafe.Offsetof(dogP.name)
       nameP := (*string)(unsafe.Pointer(namePtr))
这里需要与unsafe.Offsetof函数搭配使用才能看出端倪。unsafe.Offset函数用于获取两个值在内存中的起始存储地址之间的偏移量，以字节为单位。
这两个值一个是某个字段的值，另一个是该字段值所属的那个结构体值。我们在调用这个函数的时候，需要把指针对字段的选择表达式传给它，比如
dogP.name。有了这个偏移量，又有了结构体值在内存中的起始存储地址(这里由dogPtr变量代表)，把它们相加我们就可以得到dogP的name字段值的起始
存储地址了。这个地址由变量namePtr代表。此后，我们可以再通过两次类型转换把namePtr的值转换成一个*string类型的值，这样就得到了指向dogP的
name字段的指针值。

你可能会问，我直接用取址表达式&(dogP.name)不就能拿到这个指针值了吗？干嘛要绕这么大一圈呢？你可以想象一下，如果我们根本就不知道这个结构
类型是什么，也拿不到dogP这个变量，那么还能去访问它的name字段吗？

答案是，只要有namePtr就可以。它就是一个无符号整数，但同时也是一个指向了程序内部数据的内存地址。它可能会给我们带来一些好处。比如可以直接
修改埋藏很深的内部数据。但是，一旦我们有意或无意的把这个内存地址泄露出去，那么其他人就能够肆意的改动p.name的值，以及周围的内存地址上存储
的任何数据了。即使他们不知道这些数据的结构也无所谓，改不好还改不坏吗？好了，现在我们知道了这种手段，也知道了它的危险性，那就谨慎对待，防
患于未然吧。


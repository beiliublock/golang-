## go语句及其执行规则（上）
1. 回顾：
   <br/>我们上次一起学习了Go语言中的一些指针操作，了解到哪些是不可取址的，我们可以归纳为：不可变的，临时结果的，不安的。
   但是在临时结果中有一个例外，那就是对于切片的索引。同时，我们也一起学习了哪些操作是必须要地址类型的，例如，自增自减的
   左侧表达式必须为可取址的，同样这里也有一个例外那就是对字典类型的操作。我们也了解到，可以利用unsafe.Pointer和uintptr
   结合来访问底层数据的内存地址，但必须要同时了解到其危险性。
2. 前导：
   <br/>很棒！我们已经一起学习完了关于Go语言数据类型的全部内容。我相信你不但已经知晓了怎样高效的使用Go语言内建的那些数据
   类型，还明白了怎样正确的创造自己的数据类型(注：可以先停下来回顾一下以前的学习内容，例如自己先回忆整理一个思维导图)。
   对于Go语言的编程知识。确实已经知道不少了。不过，如果真想玩转Go语言还需要知道它的一些特色流程和语法。尤其是我们在本篇
   文章中讨论的go语句，这也是Go语言的最大特色了。它足以代表Go语言最重要的编程哲学和并发编程模式。

   我们再重温一下下面这句话：
   >**Don't communicate by sharing memory;share memory by communicating.**

   从Go语言编程的角度解释，这句话的意思就是：**不要通过共享数据来通讯，恰恰相反，要以通讯的方式共享数据**。我们已经知道，
   通道(也就是channel)类型的值，可以被用来以通讯的方式共享数据。更具体的说，它一般被用来在不同的goroutine之间传递数据。那么
   goroutine到底代表着什么呢？

   简单来说，goroutine代表着并发编程模型中的用户级线程。你可能已经知道，操作系统本身提供了进程和线程，这两种并发执行程序的工具。
#### 进程与线程
**进程**，描述的就是程序的执行过程，是运行着的程序的代表。换句话说，一个进程其实就是某个程序运行时的一个产物。如果说静静的躺在那
里的代码就是程序的话，那么奔跑着的、正在发挥着既有功能的代码就可以被称为进程。我们的电脑为什么可以同时运行那么多应用程序？我们的
手机为什么可以有那么多App同时在后台刷新？这都是因为在它们的操作系统之上有多个代表着不同程序或App的进程在同时运行。

**线程**，首先，线程总是在进程之内的，它可以被视为进程中运行着的控制流（或者说代码执行的流程）。一个进程至少会包含一个线程。如果
一个进程只包含了一个线程，那么它里面的所有代码都只会被串行的执行。每个进程的第一个线程都会随着该进程的启动而被创建，其可以被称为
其所属进程的主线程。相应的，如果一个进程中包含了多个线程，那么其中的代码就可以被并行的执行。除了进程的第一个线程(主线程)之外，其他
的线程都是由进程中已存在的线程创建出来的。

也就是说，主线程之外的其他线程都只能由代码显示的创建和销毁。这需要我们在编写程序的时候进行手动控制，操作系统以及进程本身并不会帮我
们下达这样的指令，它们只会忠实的执行我们的指令。不过，在Go程序当中，Go语言的运行时(runtime)系统会帮助我们自动的创建和销毁系统级的
线程。这里的系统级线程指的就是我们刚刚说过的操作系统提供的线程。而对应的用户级线程指的是架设在系统级线程之上的，由用户（或者说我们
编写的程序）完全控制的代码执行流程。用户级线程的创建、销毁、调度、状态变更以及其中的代码和数据都完全需要我们的程序自己去实现和处理。

这带来了很多优势，比如，因为它们的创建和销毁并不用通过操作系统去做，所以速度会很快，又比如，由于不用等着操作系统去调度它们的运行，
所以往往会很容易控制并且很灵活。但是，劣势也是有的，最明显也最重要的一个劣势就是复杂。如果我们只使用系统级线程，那么我们只要指明
需要新线程执行的代码片段，并且下达创建或销毁线程的指令就好了，其他一切具体实现都会由操作系统代劳。但是如果使用用户级线程，我们就
不得不既是指令的下达者，又是指令执行者。我们必须全权负责与用户级线程有关的所有具体实现。操作系统不但不会帮忙，还要求我们的具体实现
必须与它正确的对接，否则用户级线程就无法被并发的，甚至正确的运行。毕竟我们编写的所有代码最终都需要通过操作系统才能在计算机上执行。
这听起来就很麻烦，不是吗？

**不过别担心，Go语言不但有着独特的并发编程模型，以及用户级线程goroutine，还拥有强大的用于调度goroutine、对接系统级线程的调度
器。** 这个调度器是Go语言运行时系统的重要组成部分，它主要负责统筹调配Go并发编程模型中的三个主要元素，即：G(goroutine的缩写)、
P(processor的缩写)和M(machine的缩写)。其中的M代指的就是系统级线程。而P指的是一种可以承载若干个G(goroutine)，并且能够使这些G适时的与
M进行对接，并得到真正运行的中介。从宏观上说，G和M由于P的存在可以呈现出多对多的关系。当一个正在与某个M对接并运行着G，需要因某个事件(
比如等待I/O或锁的解除)而暂停运行的时候，调度器总会及时的发现，并把这个G与那个M分开，以释放计算资源提供那些等待运行的G使用。而当一个G
需要恢复运行的时候，调度器又会尽快的为它寻找空闲的计算资源（包括M）并安排运行。另外，当M不够用时，调度器会帮我们向操作系统申请新的系统
级线程，而当某个M已无用时，调度器又会负责把它及时的销毁。正因为调度器帮我们做了很多事，所以我们的Go程序才总是能高效的利用操作系统和计算
资源。程序中的所有goroutine也都会被充分的调度，其中的代码也都会被并发的运行，即使这样的goroutine有数以十万计，也仍可以如此。

<font size=5>**M、P、G之间的关系(简化版)**</font>

![](http://p2.so.qhmsg.com/t017e5e1098ad3b690a.jpg)

### Q：什么是主goroutine，它与我们启用的其他goroutine有什么不同？
我们先来看一段代码：思考一下输出结果，为什么？

    package main
    import "fmt"
    func main() {
        for i:=0;i<10;i++ {
            go func() {
                fmt.Println(i)
            }()
        }
    }
**典型回答**：不会有任何内容被打印出来。

**问题解析**：
<br/>与一个进程总会有一个主线程类似，每一个独立的Go程序在运行时也总会有一个主goroutine，这个主goroutine会在Go程序的运行准备工作完成后被自动
的启用，并不需要我们做任何手动的操作。想必你已经知道，每条go语句一般都会携带一个函数调用，这个被调用的函数常常被称为go函数，而主goroutine的
go函数就是那个作为程序入口的main函数。一定要注意，go函数真正被执行的时间，总会与其所属的go语句执行的时间不同。当程序执行到一条go语句的时候，
Go语言运行时系统，会先试图从某个存放空闲的G的队列中获取一个G，它只有在找不到空闲G的情况下才会去创建一个新的G。

这也就是为什么总会说“启用”一个goroutine，而不说“创建”一个goroutine的原因。已存在的goroutine总会被优先复用。但是，创建G的成本也是非常低
的。创建一个G并不会像新建一个进程或者一个系统级线程那样，必须通过操作系统的系统调用来完成，在Go语言的运行时系统内部就可以完全做到了，更何况
一个G仅相当于为需要并发执行代码片段服务的上下文环境而已。在拿到一个空闲的G之后，Go语言运行时系统会用这个G去包装当前的那个go函数（或者说该函数
中的那些代码），然后再把这个G追加到某个存放可运行的G的队列中。

这类队列中的G总会按照FIFO的顺序，很快的由运行时系统内部的调度器安排运行。虽然这会很快，但是由于上面所说的那些准备工作还是不可避免的，所以耗时
还是存在的。因此，go函数的执行时间总会明显的滞后于它所属的go语句的执行时间。当然，这里的“明显滞后”是相对于计算机的CPU时钟和Go程序来说的。我
们在大多数时候都不会有明显的感觉。

在说明了原理之后，我们再来看这种原理下的表象。请记住，只要go语句本身执行完毕，Go程序完全不会等待go函数的执行，它会立刻去执行后面的语句。也就是
所谓的异步并发的执行。这里“后面的语句”指的是一般for语句中的下一个迭代。然而，当最后一个迭代运行的时候，这个“后面的语句”是不存在的。上述d代
码中的那条for语句会以很快的速度执行完毕。当它执行完毕时，那10个包装了go函数的goroutine往往还没有获得运行的机会。

请注意，go函数中的那个对fmt.Println函数的调用是以for语句中的变量i作为参数的。可以想象一下，如果当for语句执行完毕的时候，这些go函数都还没有执行，
那么它们引用的变量i的值将会是什么？它们都会是10，对吗？在确定最终的答案之前，我们还需要知道一个与主goroutine有关的重要特性，即：**一旦主goroutine
中的代码（也就是main函数中的那些代码）执行完毕，当前Go程序就会结束运行**。如此一来，如果在Go程序结束运行的那一刻，还有goroutine未得到运行机会，
那么它们就真的没有运行机会了，它们中的代码也不会被执行。

我们刚刚谈论过，当for语句的最后一个迭代运行的时候，其中的那条go语句即是最后一条语句。所以，在执行完这条go语句之后，主goroutine中的代码也就执行完了，
Go程序会立即结束运行，那么这样的话也就意味着不会有任何内容被打印出来。

严谨的说，Go语言并不会去保证这些goroutine会以怎样的顺序运行。由于主goroutine会与我们手动启用的其他goroutine一起接受调度，又因为调度器很可能会在
goroutine中的代码只执行了一部分的时候暂停，以期所有的goroutine有更公平的运行机会。所以哪个goroutine先执行完、哪个goroutine后执行完往往是不可预知的，
除非我们使用了某种Go语言提供的方式进行人文干预。然而，在这段代码中，我们并没有进行任何人为干预。

**总结**：
<br/>虽然，go语句是按照FIFO的顺序执行的，但是我们Go语言自身并不保证go函数也是顺序执行的，需要我们进行人为的干预；主goroutine执行完毕之后，其他
goroutine就算没有执行完毕，也不再会有机会执行；根据Go并发模型来讲，当遇到一个go语句时，当这个G需要等待时，P就会将这个G分离出去，让它独立运行，
然后接入其他等待的G与M进行对接。

### 知识扩展
#### 问题1：怎样才能让主goroutine等待其他goroutine？
刚刚说过，一旦主goroutine中的代码执行完毕，当前的Go程序就会结束运行，无论其他的goroutine是否已经在运行了。那么，怎样才能做到等其他的goroutine运
行完毕之后，再让主goroutine结束运行呢？

1.**最简单的，也是最容易想到的，就是利用time.Sleep函数让主goroutine小睡一会，代码如下：**

    package main
    import "fmt"

    func main() {
         for i:=0;i<10;i++ {
             go func() {
                 fmt.Println(i)
             }()
         }
         time.Sleep(1*time.Second)
    }
time.Sleep函数的功能就是让当前的goroutine（这里就是主goroutine）暂停运行一段时间，直到到达指定的恢复运行时间。例如，这里传入的1秒。time.Sleep函数会
在被调用时用当前时间的绝对时间，再加上相对时间计算出在未来恢复运行的时间。显然，一旦到达恢复运行时间，当前的goroutine就会从“睡眠”中醒来，并开始继续
执行后面的代码。

这个办法是可行的，但是要控制好睡眠的时间。不过，问题恰恰就在这里，我们让主goroutine“睡眠”多长时间才合适呢？如果太短，达不到预期的效果，太长则纯属浪费，
这个时间太难把握了。

2.**利用通道传递信息**：
<br/>你可能会想到，既然不容易预估时间，那干脆就不要自己预估时间了，让其他的goroutine在运行完毕的时候告诉我们好了，很好的思路，但是该怎么做呢？我们再次来回顾
一句话**Don't communicate by sharing memory;share memory by communicating**(再次强调一下Go的编程哲学和并发编程模式)。是的，利用通道。我们先创
建一个通道，它的长度应该与我们手动启用的goroutine的数量一致(也就是说利用channel来控制goroutine的数量)。在每个手动启用的goroutine即将运行完毕的时候，我
们都向该通道发送一个值。

注意，这些发送表达式应该被放在它们的go函数体的最后面。对应的，我们还需要在main函数的最后从通道接收元素值，接收的次数也应该与手动启用的goroutine的数量保持
一致，详细可以参考demo2.go中的代码。其中一个细节需要注意一下。我在声明通道的时候是以`chan struct{}`作为其类型的，其中类型字面量`struct{}`有些类似于空接口
类型`interface{}`，它代表了既不包含任何字段也不用有任何方法的空结构体。注意，`struct{}`类型值的表示法只有一个，即：`struct{}{}`。并且它占用的内存空间是0
字节。确切的说，这个值在整个Go程序中永远都只会存在一份。虽然我们可以无数次的使用这个值字面量，但是用到的却都是同一个值。

当我们仅仅把通道当作传递某种简单信号的介质的时候，用struct{}作为其元素类型是再好不过的了，当然还有更好的方法，就比如利用sync包中的sync.WaitGroup类型。这个
会在以后讲sync包的时候提到。

#### 问题2：怎样让我们启用的多个goroutine按照既定的顺序运行？
我们都知道，上述问题打印出来的不是顺序的，因为goroutine的执行并不是顺序的，那么怎样可以使得多个goroutine顺序执行呢。当然串行的打印是可行的，但是问题的前提
是多个goroutine，当然了解决的思路有很多的，这里说一下常用的方法。

首先，我们需要稍微改造一下for语句中的go函数，要让它接受一个int类型的参数，并在调用它的时候把变量i的值传进去，参考代码如下：

    for i:=0;i<10;i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }
前面已经说过，在go语句被执行的时候，我们传给go函数的参数i会被先求值，如此就等到了当次迭代的序号。之后，无论go函数会在什么时候执行，这个参数值都不会变。也就
是说，go函数中调用的fmt.Println函数打印的一定会是那个当次迭代的序号。然后，我们再着手改造for语句的go函数。参考代码如下：

    for i:=uint32(0);i<10;i++ {
        go func(i uint32) {
            fn := func() {
                fmt.Println(i)
            }
            trigger(i,fn)
        }(i)
    }
我在go函数中先声明了一个匿名函数，并把它赋值给了变量fn。这个匿名函数做的事情很简单，只调用fmt.Println函数以打印go函数的参数i的值。在这之后，我调用了一个名叫
trigger的函数，并把go函数的参数i和刚刚的参数i和刚刚声明的变量fn作为参数传给它。不知道你注意了没有，for语句声明的局部变量i和go函数的参数i的类型都变了，由int变为
了uint32，这是为什么呢？我们一会再说。

再来说trigger函数。该函数接受两个参数，一个是uint32类型的参数i，另一个是func()类型的参数fn。你应该还记得，func()代表的是既无参也无结果声明的函数类型。这里贴一下
trigger函数的实现以供参考：

    trigger := func(i uint32, fn func()) {
        for {
            if n := atomic.LoadUint32(&count);n == i {
                fn()
                atomic.AddUint32(&count,1)
                break
            }
            time.Sleep(time.Nanosecond)
        }
    }
trigger函数会不断的获取一个名叫count的变量的值，并判断该值是否与参数i的值相同。如果相同，那么就立即调用fn代表的函数，然后把count变量的值加1，最后显示的退出当前的
循环，否则我们就先让当前的goroutine“睡眠”一个纳秒再进入下一个迭代。

注意，在操作变量count的时候使用的都是原子操作。这是由于trigger函数会被多个goroutine并发的调用，所以它用到的非本地变量count，就被多个用户级线程共用了。因此，对它的
操作就产生了竞态条件(race condition)，破坏了程序的并发安全性。所以，我们总是应该对这样的操作加以保护，在sync/atomic包中声明了很多用于原子操作的函数。另外，由于这里
选用的原子操作函数对被操作的数值的类型有约束，所以这才对count以及相关的变量和参数的类型进行了统一的变更（由int变为了uint32）

纵观count变量、trigger函数以及改造后的for语句和go函数，我们要做的是，让count变量成为一个信号，它的值总是下一个可以调用打印函数的go函数的序号，这个序号其实就是启用
goroutine时，当次迭代的序号。也正因如此，go函数实际的执行顺序才会与go语句的执行顺序完全一致。此外，这里的trigger函数实现了一种自旋(spinning)。除非发现条件已满足，
否则它会不断的进行检查。

最重要的是，因为我们依然想让主goroutine最后一个运行漫笔，所以还需要加一行代码。不过既然有了trigger函数，这里就没有再使用通道。

    trigger(10,func(){})
调用trigger完全可以达到相同的效果。由于当所有手动启用的goroutine都运行完毕之后，count的值一定会是10，所有这里就把10作为了第一个参数值，又由于我们只是想让其起到阻塞
的作用，所以，这里什么都不做。总之，通过上述的改造，我们使得异步并发的go函数得到看同步的（或者说按照既定顺序的运行）。可以自己尝试写一下，也可以参考一下demo3.go的代码。

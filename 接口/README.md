## 接口类型的合理运用
1. 回顾；
   <br/>我们上次讲了结构体的相关操作，了解到方法，字段之间的屏蔽，以及指针方法和值方法的区别。指针方法
   包含值方法。我们也可以通过链式调用，调用被屏蔽掉的方法。结构体字段的嵌入是无侵入式的。
2. 前导：正确使用接口的基础知识
   <br/>在Go语言的语境中，当我们在谈论“接口”的时候，一定指的是接口类型。因为接口类型与其他数据类型不同，
   它是无法被实例化的。更具体地说，我们既不能通过调用new函数或make函数创建出一个接口类型地值，也无法用字
   面量来表示一个接口类型地值。

   对于某一个接口类型来说，如果没有任何数据类型可以作为它地实现，那么该接口地值就不可能存在。我们可以用
   关键字type和interface来声明接口类型。接口类型地类型字面量与结构体类型地看起来有些相似，它们都用花括
   号包裹一些核心信息。只不过，结构体类型包裹地是它地字段声明，而接口类型包裹地是它的方法定义。

   这里需要注意的是：接口类型声明中的这些方法所代表的就是该接口的方法集合。一个接口的方法集合就是它的全部
   特征。对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征(即全部的方法)，那么它就一定是这
   个接口的实现类型。比如下面这样：

        type Pet interface{
            SetName(name string)
            Name() string
            Category() string
        }
   这里声明了一个接口类型Pet，它包含了3个方法定义，方法名称分别为SetName、Name和Category。这3个方法共同
   组成类型Pet的方法集合。只要一个数据类型的方法集合中有这个3个方法，那么它就一定是Pet接口的实现类型。这
   是一种无侵入式的接口实现方式。这种方式还有一个专有名词，叫“Duck typing”,中文常译作“鸭子类型”。可以
   在[百科](https://baike.baidu.com/item/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B)上查看详细资料。

   这有两个充分必要条件，一个是“两个方法的签名需要完全一致”，另一个是“两个方法的名称要一模一样”。显然，
   这比判断一个函数是否实现了某个函数类型更加严格一些。

   我们假设dog类型实现了Pet接口定义的所有方法，其中dog的指针方法实现了SetName，正因如此，我们可以声明并初
   始化一个dog类型的比变量d，然后把它的指针值赋给类型为Pet的变量pet。此时我们可以这样写：

        d := dog{"little pig"}
        var pet Pet = &d
   这里有几个名词需要记住一下。对于一个接口类型的变量来说，例如上面的变量pet，我们赋给它的值可以被叫做它的
   实际值（也称**动态值**），而该值的类型可以被叫做这个变量的实际类型（也称**动态类型**）。比如，我们把取
   址表达式&dog的结果赋给了变量pet，这时这个结果值就是变量pet的动态值，而此时结果值的类型*dog就是该变量的动
   态类型。

   动态类型这个叫法是相对于**静态类型**而言的。对于变量pet来讲，它的静态类型就是Pet，并且永远是Pet，但是它
   的动态类型却会随着我们赋给它的动态值而变化。比如，只有我把一个`*dog`类型的值赋给变量pet之后，该变量的动态类
   型才会是`*dog`。如果还有一个Pet接口的实现类型`*flash`，并且我又把一个此类型的值赋给了pet，那么它的动态类型
   就会变为`*flash`。并且，在我们给一个接口类型的变量赋予实际值之前，它的动态类型是不存在的。

### Q：当我们为一个接口变量赋值时会发生什么？
为了突出问题，我们先把Pet接口的声明简化一下：

    type Pet interface {
        Name()  string
        Category() string
    }
现在，先声明并初始化一个gog类型的变量d，这时它的name字段的值是"little pig"。然后，把该变量赋给一个Pet类型的
变量。最后通过调用d的方法SetName把它的name字段的值修改成"monster"

    d := dog{"little pig"}
    var pet Pet = d
    d.SetName("monster")
那么在以上代码执行后，pet变量的字段name的值会是声什么？

**这个问题的典型回答是：** pet变量的字段name的值依然是"little dog"

**问题解析**：
<br/>虽然d的name字段会变为"monster"，但是pet的name值却不会，为什么呢？这里有一条通用的规则需要知晓：如果我们
使用一个变量给另外一个变量赋值，那么真正赋给后者的，并不是前者持有的那个值，而是该值的一个副本。

当知道这条动用规则之后，缺失可以把这题做对。不过，如果当我问你为什么的时候你只说出了这一个原因，那么，它只能说
你仅仅打对了一半。那么另一半是什么呢？这就需要从接口类型值的存储方式和结构说起了。在前面说过，接口类型本身是无
法被值化的。在我们赋予它实际的值之前，它的值一定会是nil，这也是它的零值。反过来讲，一旦它被赋予了某个实现类型的
值，它的值就不再是nil了。不过要注意，即使我们像前面那样把d的值赋给了pet，pet的值与d的值也是不同的。这不仅仅是副
本与原值的那种不同。当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存储在一个专用的数据结构
中。我们就把这个专用的数据结构叫做iface吧，在Go语言的runtime包中它其实就叫这个名字。

iface的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据
结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径，等等。总之，接口变量被赋予动
态值的时候，存储的是包含了这个动态值的副本的一个结构更为复杂的值。

#### 知识扩展
**问题1：接口变量的值在什么情况下才真正为nil？**
<br/>这个问题初看起来就不是个问题。对于一个引用类型的变量，它的值是否为nil完全取决于我们赋给它什么，是这样吗？我们
先来看一段代码：

    var dog1 *Dog
    fmt.Println("The first dog is nil, [wrap1]")
    dog2 := dog1
    fmt.Println("The second dog is nil, [wrap1]")
    var pet Pet = dog2
    if pet == nil {
        fmt.Println("The pet is nil, [wrap1]")
    }else {
        fmt.Println("The pet is not nil, [wrap1]")
    }
这段代码，先声明了一个*Dog类型的dog1，并且没有对它进行初始化。这时变量的值显然是nil。然后我把该变量赋给了dog2，后者
的值此时也必定是nil，对吗？现在问题来了：当我把dog2赋给Pet类型的变量pet之后，变量pet的值会是什么？答案是nil吗？根据
上面的表述，我们知道接口类型是由一个复杂的数据结构(iface)保存的，动态值只是它的一部分，所以应该不是nil。我们接着往下
看。

当我们把dog2的值赋给变量pet的时候，dog2的值会先被复制，然后Go语言会用iface的实例包装这个dog2值的副本，这里是nil。虽然
被包装的动态值是nil，但是pet的值却不会是nil，因为这个动态值只是pet值的一部分而已。顺便说一句，这时pet的动态类型就存在了，
是*Dog。我们可以通过fmt.Printf函数和占位符%T来验证这一点，另外reflect包的TypeOf函数也有类似的作用。

换个角度来看。我们把nil赋给了pet，但是pet的值却不是nil。这很奇怪对吗？其实不然，在Go语言中，我们把由字面量nil表示的值叫
做无类型的nil。这是真正的nil，因为它的类型也是nil的。虽然dog2的值是真正的nil，但是当我们把这个变量赋给pet的时候，Go语言
会把它的类型和值放在一起考虑。也就是说，这时Go语言会识别出赋予pet的值是一个*Dog类型的nil。然后，Go语言就会用iface的实例
包装它，包装后的产物肯定就不是nil了。

只要我们把一个**有类型的nil赋给接口变量**，那么这个变量的值就一定不会是那个真正的nil。因此，当我们使用类型判等符号==判断pet
是否与字面量nil相等的时候，答案一定会是false。那么，怎样才能让一个接口变量的值真正为nil呢？要么只声明它不做初始化，要么直接把
字面量nil赋给它。

**问题2：怎样实现接口之间的组合？**
<br/>接口类型间的嵌入也被称为接口的组合。在前面讲过结构体类型的嵌入字段，这其实就是在说结构体类型间的嵌入。接口类型间的嵌入要更
简单一些，因为它不会涉及方法间的“屏蔽”。只要组合的接口之间有同名的方法就会产生冲突，从而无法通过编译，即使同名方法的签名不同也
是如此。因此，接口的组合根本不可能导致“屏蔽”现象的出现。

与结构体类型间的嵌入很相似，我们只要把一个接口类型的名称直接写到另一个接口类型的成员列表中就可以了。比如：

    type Animal interface {
        ScientificName() string
        Category() string
    }

    type Pet interface {
        Animal
        Name() string
    }
Go语言团队鼓励我们声明体量较小的接口，并建议我们通过这种接口间的组合来扩展程序、增加程序的灵活性。这是因为相比于包含和多方法的大
接口而言，小接口可以更加专注的表达某一种能力或某一类特征，同时也更容易被组合在一起。

Go语言标准库代码包io中的ReadWriteCloser接口和ReadWriter接口就是这样的例子，它们都是由若干个小接口组合而成。以io.ReadWriteCloser
接口为例，它是由io.Reader、io.Writer和io.Closer这三个接口组成的。这三个接口都只包含了一个方法，是典型的小接口。它们中的每一个都只
代表了一种能力。我们编写这几个小接口的实现类型通常都会很容易。并且，一旦我们同时实现了它们，就等于实现了它们的组合io.ReadWriteCloser。
总之，善于用接口组合和小接口可以让程序框架更加稳定和灵活。可以参考demo1.go代码


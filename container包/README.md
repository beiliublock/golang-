## container包中的那些容器
1. 回顾：
   <br/>我们上次学习了数组和切片的部分相关知识，这里我们先回顾一下。切片可以类比成窗口，
   透过窗户看到的元素就是切片的长度，而切片的容量也就是其底层数组的长度。切片是引用类型，
   数组是值类型
2. 前导：
   <br/>我们学习数据结构的时候，总是会把数组和链表放在一起讲。那么今天我们就来一起学习一
   下Go语言中原生封装的链表结构。Go语言的链表实现在标准库的container/list代码包中

### Q：我们可以把自己生成的Element类型传给链表吗？
这里首先，我们先来看一下Go语言中对Element类型的定义：

    type Element struct {
    	// Next and previous pointers in the doubly-linked list of elements.
    	// To simplify the implementation, internally a list l is implemented
    	// as a ring, such that &l.root is both the next element of the last
    	// list element (l.Back()) and the previous element of the first list
    	// element (l.Front()).
    	next, prev *Element

    	// The list to which this element belongs.
    	list *List

    	// The value stored with this element.
    	Value interface{}
    }
我们发现，后继节点，前驱节点，链表本身都是未导出的字段，只有值是导出的，所以我们发现连生成
符合链表逻辑的Element类型的值都是困难的，也就是说，我们没有办法确保自己生成的Element类型值
是存在于链表上的,那么使用MoveBefore、MoveAfter、MoveToFront、MoveToBack将自己生成的值传给
链表也就是没有意义的，因为根本不会对链表做出任何改动。可以看一下demo1.go中的代码

#### 知识扩展
1. **Q：为什么链表可以做到开箱即用？**
   <br/>List和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有特定结构，
   但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予各自类型的零值。
   >广义来讲，所谓的零值就是只做了声明，但还未做初始化的变量被赋予的缺省值。每个类型的零值都会
   依据该类型的特性而被设定。
   <br/><br/>比如，经过语句`var a [2]int`声明的变量a的值，将会是一个包含了两个0的整数数组。
   又比如，经过语句`var s []int`声明的变量s的值将会是一个[]int类型的、值为nil的切片

   那么经过语句var li list.List声明的变量li的值将会是什么呢？`li`这个零值将会是一个长度为
   0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容。那这样的链表我们
   可以直接拿来使用吗？

   毋庸置疑，是可以的。这被称为“开箱即用”。Go语言标准库中有很多结构体类型的程序实体都
   做到了开箱即用。这也是在编程写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳
   实践之一。那么，语句`var li list.List`声明的链表li可以直接使用，这是怎么做到的呢？

   **关键在于它的“延迟初始化”机制。**

   所谓的**延迟初始化**，我们可以理解为把初始化操作延后，仅在实际需要的时候才进行。延迟初始化
   的优点在于“延后”，它可以分散初始化操作带来的计算量和存储空间消耗。
   <br/>例如，如果我们需要集中声明非常多的大容量切片的话，那么那时的CPU和内存空间的使用量
   肯定都会是一个激增，所以只有设法让其中的切片及其底层数组被回收，内存使用量才会有所降低。
   <br/>如果数组是可以被延迟初始化的，那么计算量和存储空间的压力就可以被分散到实际使用它们的
   时候。这些数组实际使用的时间越分散，延迟初始化带来的优势就会越明显。
   >实际上，Go语言的切片就起到了延迟初始化其底层数组的作用；
   <br/><br/>延迟初始化的缺点恰恰也在于“延后”。可以想象一下，如果我在调用链表的的每个方法
   的时候，它们都需要先判断链表是否已经被初始化，那这也会是一个计算量上的浪费。在这些方法被
   非常频繁的调用的情况下，这种浪费的的影响就开始显现了，程序的性能将会降低。

   在这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方法，一旦发现
   链表的长度为0，直接返回nil就好了。

   又比如，在用于删除元素、移动元素、以及一些用于插入元素的方法中，只要判断一下传入的元素中指向
   所属链表的指针，是否与当前链条的指针相等就可以了。

   如果不相等，就一定说明传入的元素不是这个链表中，后续的操作就不用做了。反之，就一定说明这个链表
   已经初始化了。原因在于，链表的PushFront、PushBack以及PushFrontList方法总会先判断链表的状态，并
   在必要时进行初始化，这就是延迟初始化。而且，我们在向一个空的链表中添加新元素的时候，肯定会调用
   这四个方法中的一个，这时新元素中指向所属链表的指针，一定会被设定为当前链表的指针。所以，指针相等
   是链表已经初始化的充分必要条件。

   明白了吗？List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化地优缺点，使得链表可以
   开箱即用，并且在性能上可以达到最优。

2. **Q：Ring与List的区别在哪里？**
   <br/>container/ring包中的Ring类型实现的是一个循环链表，也就是我们俗称的环。其实List在内部就是一个
   循环链表。它的根元素(哨兵节点)永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表
   的首尾两端

   所以也可以说，List的零值只是一个包含了根元素，但不包含任何实际元素值的空链表。那么，既然Ring和List在
   本质上都是循环链表，那它们到底有什么不同呢？

   最主要的不同有下面几种。
   <br/>&emsp;&emsp;1.Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。
   这是表示方式上的不同，也是结构复杂度上的不同。我们可以看一下定义它们的源代码：

        //Ring结构定义的源码
        type Ring struct {
        	next, prev *Ring
        	Value      interface{} // for use by client; untouched by this library
        }
        //List结构定义的源码
        type List struct {
        	root Element // sentinel list element, only &root, root.prev, and root.next are used
        	len  int     // current list length excluding (this) sentinel element
        }
   &emsp;&emsp;2.一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类型的值则代表
   了一个完整的链表。这是表示维度上的不同。
   <br/>&emsp;&emsp;3.在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值
   来说却不能这样做(也没有必要这样做)。循环链表一旦被创建，其长度是不可变的。这是两个代码包中的New函数在功能
   上的不同，也是两个类型在初始化值方面的第一个不同。
   <br/>&emsp;&emsp;4.仅通过`var r ring.Ring`语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一
   个长度为0的链表。别忘了List中的根元素不会持有实际元素值，因此计算长度时不会包含它。这说两个类型在初始化值方
   面的第二个不同。
   <br/>&emsp;&emsp;5.Ring值的Len方法的算法复杂度是O(N)的，而List值的Len方法的算法复杂度则是O(1)的。这是两者
   在性能方面最显而易见的差别。同样，我们在这里也贴一下代码：

        //Ring中Len()方法的源码
        func (r *Ring) Len() int {
        	n := 0
        	if r != nil {
        		n = 1
        		for p := r.Next(); p != r; p = p.next {
        			n++
        		}
        	}
        	return n
        }
        //List中Len()方法的源码
        func (l *List) Len() int { return l.len }

   其他的不同基本上都是方法方面的了。比如，循环链表也有用于插入、移动或删除元素的方法，不过用起来都显得更抽象
   一些，等等。

#### 参考阅读：
   **切片与数组的比较**
   <br/>切片本身有着占用内存少和创建便捷等特点，但它的本质还是数组。切片的一大好处是可以让我们通过窗口快速的
   定位并获取、或者修改底层数组中的元素。

   不过，当我们想删除切片(或者说数组)中的元素时就没那么简单了。元素复制一般是免不了的，就算只是删除一个元素，
   有时也会造成大量的元素移动。（所以说删除数组元素的时间复杂度是O(N)）。同时，还需要注意空出的元素槽位的"清空"，
   否则很可能会造成内存泄漏。我相信在学习数据结构与算法的时候老师一定介绍的很清楚的。

   另一方面，在切片被频繁“扩容”的情况下，新的底层数组会不断产生，这时内存分配以及元素复制的次数可能就很可观了，
   这肯定会对程序的性能产生负面的影响。所以，如果我们提前知道大概的数据量大小，应该构建适当的切片大小，避免性能
   的降低。

   当然，我相信，对于可扩容数组，数组，链表的关系，在网络普及的今天都有很多资料可以参考，所以这里就不赘述了，在
   整理完Go资料后，我可能会开始着手整理数据结构与算法的相关资料，我相信我在上面一定会列出它们的详细比较。
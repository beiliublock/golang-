## 数组和切片
1. 回顾:
   <br/>我们上次讲了程序实体(尤其是变量)及其相关的各种概念和编程技巧(比如类型推断、变量重声明、
   可重名变量、类型断崖、类型转换、别名类型和潜在类型等)。
2. 前导：
   + 我们这次主要讨论Go语言的数组(array)类型和切片(slice)类型。它们的共同点是都属于集合类的
   类型，并且，它们的值也都可以用来存储某一种类型的值(或者说元素)。不过，它们最重要的不同是：
   **数组类型的值(以下简称数组)的长度是固定的，而切片类型的值(以下简称切片)是可变长的**。
   + 数组的长度在声明它的时候就必须给的给定，并且之后不会再改变。可以说，数组的长度是其类型的
   一部分。例如：[1]string和[2]string就是两个不同的数据类型。
   + 而切片的类型字面量中只有元素的类型，没有长度。切片的长度可以自动地随着其中元素数量的增长
   而增长，但不会随着元素数量的减少而减少
   + 我们其实可以把切片看做是对数值的一层简单的封装，因为在每个切片的底层数据结构中，一定会包含
   一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对数组的某个连续片段的引用。
   >也正因如此，Go语言的切片类型属于引用类型，同属引用类型的还有字典类型(map)、通道类型(channel)、
   函数类型(func)等；而Go语言的数组类型则属于值类型，同属值类型的有基础数据类型以及结构体类型(struct)。
   <br/><br/>注意，Go语言里不存在像Java等编程语言中令人困惑的“传值或传引用”问题。在Go语言中，
   我们判断所谓的“传值”或者“传引用”只要看被传递的值的类型就好了。
   <br/><br/>如果传递的值是引用类型的，那么就是“传引用”。如果传递的值是值类型的，那么就是“传值”。
   从传递成本的角度讲，引用类型的值往往要比值类型的值低很多。
   <br/><br/>我们在数组和切片之上都可以应用索引表达式，得到的都会是某个元素。我们在它们上也都可以
   应用切片表达式，也都会得到一个新的切片
   + 我们通过调用内建函数len，可以得到数组和切片的长度。通过内建函数cap，我们可以得到它们的容量，
   但要注意，数组的容量永远等于其长度，都是不可变的。切片的容量却不是这样，并且它的变化是有迹可循
   的。

### Q：怎样正确估算切片的长度和容量？
老规矩，我们先来看一段代码：demo1.go

    package main

    import "fmt"

    func main() {
    	s1 := make([]int, 5)
    	fmt.Printf("The length of s1: %d\n", len(s1))
    	fmt.Printf("The capacity of s1: %d\n", cap(s1))
    	fmt.Printf("The value of s1: %d\n", s1)
    	s2 := make([]int, 5, 8)
    	fmt.Printf("The length of s2: %d\n", len(s2))
    	fmt.Printf("The capacity of s2: %d\n", cap(s2))
    	fmt.Printf("The value of s2: %d\n", s2)
    }
现在，具体问题是：切片s1和s2的容量都是多少？
<br/>回答：切片s1和s2的容量分别是5和8

   + **问题解析**
     1. 当我们用make函数初始化切片时，如果不指明其容量，那么它就会和长度一致。如果在初始化时指明了
     容量，那么切片的实际容量就是它了，这也正是为什么s1的容量是5，而s2的容量是8的原因了
     2. 我们回顾一下，刚刚对切片的介绍：我们其实可以把切片看做是对数值的一层简单的封装，因为在每个
     切片的底层数据结构中，一定会包含一个数组。数组可以被叫做切片的底层数组，而切片也可以被看作是对
     数组的某个连续片段的引用。因此我们可以认为切片的容量实际上就代表了它的底层数组的长度。（注意，
     切片的底层数组任然是我们前面讲的数组，其长度不可变）
     3. 关于数组和切片的关系，我们可以做这样的想象：**有一个窗口，你可以通过这个窗口看到一个数组，
     但是不一定能看到该数组中的所有元素，有时候只能看到连续的一部分元素**。现在，这个数组就是切片
     s2的底层数组，而这个窗口就是切片s2本身。s2的长度实际上指明的就是这个窗口的宽度，决定了我们透过s2,
     可以看到其底层数组中的哪几个连续的元素
     4. 请记住，当我们用make函数或切片字面量(例如：[]int{1,2,3})初始化切片时，该窗口最左边的那个小格
     子总是会对应其底层数组中的第一个元素，但是当我们通过切片表达式基于某个数组或切片生成新切片的时候，
     情况就会变得复杂起来：

            我们再来看一个例子：
            s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
            s4 := s3[3:6]
            fmt.Printf("The length of s4: %d\n", len(s4))
            fmt.Printf("The capacity of s4: %d\n", cap(s4))
            fmt.Printf("The value of s4: %d\n", s4)
     切片s3中有8个元素，分别是从1到8的整数。s3的长度和容量都是8。然后，我用切片表达式`s3[3:6]`初始化
     了切片s4。问题是，这个s4的长度和容量分别是多少？
     <br/><br/>这个并不难，用减法就可以求出长度，这里需要注意的是，切片表达式其实是左闭右开的，即：
     [3,6)，这个是数学中常用的区间表示法。这里的3可以被称为起始索引，6可以被称为结束索引。所以s4的
     长度就是6-3=3。因此可以说，s4中的索引从0到2指向的元素对应的是s3及其底层数组中索引从3到5的那三
     个元素
     <br/><br/>再来看容量，前面说过，切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者
     切片值字面量初始化切片的情况。**更通用的规则是：一个切片的容量可以被看作是透过这个窗口最多可以
     看到的底层数组中元素的个数。（注意，切片代表的窗口是无法向左扩展的，仅可以向右扩展），所以s4的
     容量就是cap(s3)-3=5。

#### 知识扩展
  1. Q1：怎样估算切片容量的增长？
     + 一旦一个切片无法容纳更多的元素，Go语言就会想办法扩容。但它并不会改变原来的切片，而是会生成一个
     容量更大的切片，然后将原有的元素和新元素一并拷贝到新切片中
     + 当切片的长度(以下简称原长度)小于1024时(len < 1024)，新切片的容量(以下简称新容量)将会是原切片容
     量的(以下简称原容量)的2倍。(cap *= 2)
     + 当原长度大于或等于1024时，go语言将会以原容量的1.25倍作为新容量的基准(以下简称新容量基准)。新容量
     基准会被调整(不断的与1.25相乘)，直到结果不小于原长度与要追加的元素数量之和(以下简称新长度)。最终，新
     容量往往会比新长度大一些，当然相等也是可能的
     + 另外，如果我们一次追加的元素过多，以至于使得新长度原容量的2倍还要大，那么新容量就会以新长度为基准。
     更多细节可以参见runtime包中slice.go文件里的growslice及相关函数的具体实现
     + 我把展示上述扩容策略的一些例子都放到了demo2.go文件中，可以参考一下
  2. Q2：切片的底层数组什么时候会被替换
     + **确切的说，一个切片的底层数组永远不会被替换。** 虽然在扩容的时候Go语言一定会生成新的底层数组，
     但是它也同时生成了新的切片。它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做
     任何改动。
     + 请记住，在无需扩容时，append函数返回的是指向原底层数组的新切片，而在需要扩容时，append函数返回的是
     指向新底层数组的新切片。
     + 顺便说一下，只要新长度不会超过切片的原容量，那么使用append函数对其追加元素的时候就不会引起扩容，这
     只会使紧邻切片窗口右边的(底层数组中的)元素被新的元素替换掉。可以看一下demo3.go的代码

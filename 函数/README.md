## 使用函数的正确姿势
1. 回顾：
   <br/>上次我们一起学习了Go语言中的通道操作，以及select以及通道的配合使用，还有造成
   通道阻塞和引发panic的几种情况，知道手动关闭通道是必要的
2. 前导：**函数是一等公民**
   <br/>在Go语言中，函数是一等的(first-class)公民，函数类型也是一等的数据类型。简单来
   说，这意味着函数不但可以用于封装代码、分割功能、解耦逻辑，还可以化身普通的值，在其他
   函数间传递、赋予变量、做类型判断和转换等等。而更深层次的含义就是：函数值可以由此成为能
   够被随意传播的独立逻辑组件(或者说功能模块)
   <br/>对于函数来说，它是一种对一组输入、输出进行模块化的重要工具，它比接口类型更加轻巧、
   灵活，它的值也借此变成了可被热替换的逻辑组件。这里贴一下代码：可以参考以下demo1.go

        package main
        import "fmt"
        //声明一个名叫printer的函数类型
        type printer func(contents string) (n int,err error)

        func printToStd(contents string) (bytesNum int,err error) {
            return fmt.Println(contents)
        }

        func main() {
            var p printer
            p = printToStd
            p("something")
        }
   书写函数签名的方式与函数声明的是一致的。只是紧挨在参数列表左边的不是函数名称，
   而是关键字func。这里函数名称和func互换了一下位置。
   >函数的签名其实就是函数的参数列表和结果列表的统称，它定义了可用来鉴别不同函数的那些特征，
   同时也定义了我们与函数交互的方式

   只要两个函数的参数列表和结果列表中的元素顺序及其类型是一致的，我们就可用说它们是一样的函数，或者说
   是实现了同一个函数类型的函数。

   总之，“函数是一等公民”是函数式编程(functional programming)的重要特征。Go语言在语言层面支持了
   函数式编程。

### Q：怎样编写高阶函数？
先来说一下什么是高阶函数？简单来说，高阶函数可以满足下面的两个条件：
1. **接受其他的函数作为参数传入；**
2. **把其他的函数作为结果返回**

只要满足了其中任意一个特点，我们就可以说这个函数是一个高阶函数。高阶函数也是函数式编程中
的重要概念和特征。

我们把这个问题描述的具体一些：我想通过编写calculate函数来实现两个整数间的加减乘除运算，但是希望
两个整数和具体的操作都由该函数的调用方给出，那么，这样一个函数应该如何编写？

A：首先，我们声明一个名叫operate的函数类型，它有两个参数和一个结果，都是int类型的。

       type operate func(x,y int) int
   然后，我们编写calculate函数的签名部分。这个函数除了需要两个int类型的参数之外，还应该有一个operate
   类型的参数。该函数的结果应该有两个，一个是int类型的，代表真正的操作结果，另一个应该是error类型的，
   因为如果那个operate类型的参数值为nil，那么就应该直接返回一个错误。
   >顺便说一下，函数类型属于引用类型，它的值可以为nil，而这种类型的零值恰恰就是nil

       func calculate(x,y int, op operate) (int,error) {
            if op == nil {
                return 0,errors.New("invalid operation")
            }
            return op(x,y),nil
       }
   calculate函数实现起来就很简单了。我们需要先用卫述语句检查一下参数，如果operate类型参数op为nil，
   那么就直接返回0和一个代表了具体错误的error类型值
   >用卫述语句是指用来检查关键的先决条件的合法性，并在检查未通过的情况下立即终止当前代码块执行的
   语句。在Go语言中，if语句常被称为用卫述语句。

**问题解析**
  + 其实只要明白了“函数是一等的公民”这句话背后的含义，这道题就会很简单。第一点：把函数作为一个普通的
  指赋给一个变量；第二点：让函数在其他函数间传递。
  + 只要我们传入的函数类型签名与operate类型的签名一致，并且实现得当就可以。这里贴一下代码：

        op := func(x,y int) int {
            return x + y
        }
    calculate函数就是一个高阶函数。但是我们说高阶函数的特点有两个，而该函数只展示了其中一个特点，即：
    接受其他的函数作为参数传入。另一个特点，把其他函数作为结果返回，可以参考一下demo2.go的代码。

#### 知识扩展
**问题1：如何实现闭包？**
<br/>闭包又是什么？你可以想象一下，在一个函数中存在对外来标识符的引用。所谓的外来标识符，既不代表当前
函数的任何参数或结果，也不是函数内部声明的，它是直接从外边拿过来的。

还有个专门的术语称呼它，叫自由变量，可见它代表的肯定是以哦个变量。实际上，如果它是个常量，那也就形不成
闭包了，因为常量是不可变的程序实体，而闭包体现的却是由“不确定”变为“确定”的一个过程。闭包函数就是因为
引用了自由变量，而后者到底代表了什么在闭包函数被定义的时候却是未知的。

即使对于像Go语言这种静态语言类型的编程语言而言，我们在定义闭包函数的时候最多也只能知道自由变量的类型。在
demo2.go中的genCalculate函数内部，实际上就实现了一个闭包函数，而genCalculate函数也是一个高阶函数。这里
贴一下代码：

        func genCalculate(op operate) calculateFunc {
            return func(x,y int) (int,error) {
                if op == nil {
                    return 0,errors.New("invalid operation")
                }
                return op(x,y),nil
            }
        }
genCalculate函数只做了一件事，那就是定义一个匿名的、calculateFunc类型的函数并把它作为结果值返回。而这个
匿名函数就是一个闭包函数。它里面使用的变量op既不代表它的任何参数或结果也不是它自己声明的，而是定义它的
genCalculate函数的参数，所以是一个自由变量。这个自由变量究竟代表了什么，这一点并不是在定义这个闭包函数的
时候确定的，而是在genCalculate函数被调用的时候确定的。只有给定了该函数的参数op，我们才知道它返回给我们
的闭包函数可以用于什么运算。

看到`if op == nil`那一行了吗？Go语言编译器读到这里时会试图去寻找op所代表的东西，它会发现op代表的是
genCalculate函数的参数，然后它会把这两者联系起来。这时，我们可以说自由变量op被“捕获”了。当程序运行
到这里的时候，op就是那个参数值了。如此一来，这个闭包函数的状态就由“不确定”变为了“确定”，或者说转
到了“闭合”状态，至此也就真正的形成了一个闭包。

那么，实现闭包的意义又在哪里呢？表面上看，我们知识延迟实现了一部分程序逻辑功能而已，但实际上，我们是在
动态的生成那部分程序逻辑。我们可以借此在程序运行的过程中，根据需要生成功能不同的函数，继而影响后续的程序
行为。这与GoF设计模式中的“模板方法”模式有着异曲同工之妙，不是吗？

**问题2：传入函数的那些参数值后来怎么样了？**
<br/>同样的，我们先贴一段代码看一下：

    package main
    import "fmt"
    func main() {
        array1 := [3]string{"a","b","c"}
        fmt.Printf("The arrary:%v\n",array1)
        array2 := modifyArray(array1)
        fmt.Printf("The modified array:%v\n",array2)
        fmt.Printf("The original array:%v\n",array1)
    }

    func modifyArray(a [3]string) [3]string {
        a[1] = "x"
        return a
    }
答案是，原数组array1并不会发生改变，由于数组是值类型，且Go语言中只有浅拷贝，所以传的只是array1的副本。
但如果数组中某个元素是一个引用类型，我们荏苒需要注意，因为虽然其任然是浅拷贝，但副本却是底层数组的地址，
所以任然会发生改变。

#### 总结：
+ Go语言是通过函数的签名来鉴别一个函数的
+ 函数是Go语言支持函数式编程的主要体现。我们可以通过“把函数传给函数”以及“让函数返回函数”来编写
  高阶函数，也可以用高阶函数来实现闭包，并以此做到部分程序逻辑的动态生成。
+ 说一些关于函数传参的一个注意事项 ，这很重要，可能会关系到程序的稳定与安全，一个相关原则是：既不要
  把你程序的细节暴露给外界，也尽量不要让外界的变动影响到你的程序。
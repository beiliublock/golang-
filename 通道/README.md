## 通道的相关操作
1. 回顾：
   <br/>我们上次讲了map的一些基本知识，学习了字典类型键值类型的约束和底层的存储原理，
   以及对未初始化map的哪些操作是被允许的，哪些又是不被允许的
2. 前导：
   <br/>作为Go语言最有特色的数据类型，通道(channel)完全可以与goroutine(go程/协程)
   并驾齐驱，共同代表Go语言独有的并发编程模式和编程哲学。
   >Don't communicate by sharing memory;share memory by communicating.
   <br/>(不要通过共享内存来通信，而应该通过通信来共享内存)

### 通道的基础知识
通道类型的值本身就是并发安全的，这也是Go语言自带的、唯一一个可以满足并发安全性的类型。
在声明并初始化一个通道的时候，我们需要用到Go语言的内建函数make。就像用make初始化切片
那样，我们传给这个函数的第一个参数应该是代表了通道的具体类型的类型字面量。如：chan int，
chan表示通道类型的关键字，int表示该通道类型的元素类型。

在初始化通道的时候，还可以接收一个可选的int类型的参数，用于表示该通道的容量。当容量为0时，
我们称其为“非缓冲通道”，当容量大于0时，我们称其为“缓冲通道”；它们有着不同的数据传输方式。

**一个通道相当于一个先进先出的队列。也就是说，通道中的各个元素值都是严格的按照发送顺序排列的，
先被发送的通道元素一定会被先接收。元素值的发送和接收操作符都是<-**，可以参考一下demo1的代码。

#### Q：对通道的发送和接收操作都有哪些基本的特性？
它们的基本特性如下：
1. 对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
2. 发送操作和接收操作中对元素值的处理都是不可分割的
3. 发送操作在完全完成之前会被阻塞。接收操作也是如此

**问题解析：**
1. 我们先来看第一个基本特性。在同一时刻，Go语言的运行时系统只会执行对同一个通道的任意个发送操作中的某
一个。直到这个元素被完全复制进该通道之后，其他针对该通道的发送操作才可能被执行，即使这些操作是并发执行的。
接收操作亦是如此。这里所谓的并发执行，可以理解为，多个代码块分别在不同的goroutine之中，并有机会在同一时间
段内被执行。另外，对于通道中的同一个元素值来说，发送操作和接收操作也是互斥的。例如，虽然会出现，正在被复制
进通道但还未复制完成的元素值，但是这时它绝对不会想被接收它的一方看到或取走。
<br/><br/>**这里需要注意的一个细节是，元素值从外界进入通道时会被复制。更具体地说，进入通道地并不是接收操作符
右边地那个元素值，而是它地副本。**
<br/><br/>另一方面，元素值从通道进入外界时会被移动。这个移动操作实际上包含了两步，第一步是生成正在通道中地
这个元素的副本，并准备给到接收方，第二步是删除在通道中的这个元素值。

2. 顺着这个细节我们再来看一下第二个基本特性。这里的“不可分割”是指，它们处理元素值时都是一气呵成的，绝不会
被打断。这既是为了保证通道中元素值的完整性，也是为了保证通道操作的唯一性。所谓的唯一性是指，对于通道中的同
一元素值来说，它只可能是某一发送操作放入的，同时也只可能被某一个接收操作取出。

3. 再来说第三个基本特性，一般情况下，发送操作包括了“复制元素值”和“放置副本到通道内部”这两个步骤。在这两个
步骤完全完成之间，发起这个发送操作的那句代码会一直阻塞在那里，也就是说，在它之后的代码不会有执行的机会，直到这句
代码的阻塞解除。更细致的说，在通道完成发送操作之后，运行时系统会通知这句代码所在的goroutine，以使它去争取继续运行
这行代码的机会。
<br/><br/>另外，接收操作通常包含了“复制通道内的元素值”，“放置副本到接收方”，“删掉原值”这三个步骤。和发送操作
一样，接收操作在所有这些步骤完成之前，发起操作的代码也会一直阻塞。
<br/><br/>**如此阻塞代码其实就是为了实现操作的互斥和元素值的完整**

#### 知识扩展
**问题1：发送操作和接收操作在什么时候可能被长时间的阻塞？**
+ 先说针对**缓冲通道**的情况。如果通道已满，那么对它的所有发送操作都会被阻塞，直到通道中有元素值被接走。这时，
  通道会优先通知最早因此而等待的、那个发送操作所在的goroutine，后者会再次执行发送操作。相对的，接收操作
  也是如此。
+ 对于**非缓冲通道**，情况简单一些。无论是发送操作还是接收操作，一开始执行就会被阻塞，直到配对的操作也开始执行，
  才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有发送双方对接上了，数据才会被传递。并
  且，数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。相比之下，缓冲通道则是用异步的方式传递数据。
+ 大多数情况下，缓冲通道会作为收发双方的中间件。但是，当发送操作在执行的时候，发现空的通道中正好有等待的接收操作，
  那么它会直接把元素值复制给对方。
+ 以上说的都是在正确使用通道的前提下会发生的事，下面特别说明一下，由于错误使用通道而造成的阻塞。对于值为nil的通道，
  (未初始化的通道)，不论它的具体类型是什么，它们都会永久阻塞在那一行代码上，所以在使用通道的时候，尽量使用make函数
  声明并初始化。可以参考一下demo2.go中的代码，我罗列上述会导致阻塞的3种情况。

**问题2：发送操作和接收操作在什么时候会引发panic？**
+ 对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发panic。但是通道一旦关闭，再对它进行发送操作，就会引
  发操作，就会引发panic。另外，如果我们试图关闭一个已经关闭了的通道，也会引发panic。注意，接收操作是可以感知到通道
  关闭的，并能够安全退出。
+ 更具体地说，当我们把接收表达式地结果同时赋给两个变量时，第二个变量地类型就一定是bool类型。它地值如果为false就说明
  通道已经关闭，并且再没有元素值可取了。注意，如果通道关闭时，里面还有元素值未被取出，那么接收表达式地第一个结果，仍
  会是通道中地某一个元素值，而第二个结果值一定会是true。
+ 因此，通过接收表达式地第二个结果值，来判断通道是否关闭是可能有延时的。由于通道的收发操作有上述特性，所以除非有特殊
  的保障措施，我们千万不要让接收方关闭通道，而应当让发送方做这件事。可以参考一下demo3.go中的代码

**问题3：通道的长度代表着什么？它在什么时候会和通道的容量相同**
  + 长度代表通道当前包含的元素个数，容量就是初始化时设置的个数
  + 另外补充一下，元素值在经过通道传递时会被复制，所以这种复制是浅拷贝，可以参考一下demo4.go中的代码

**回答整理**
  + 通道需要手动关闭（这是一个很好的习惯），而且也可以利用关的动作来给接收方传递一个信号。Go的GC只会
    清理被分配到堆上的、不再有任何引用的对象；
  + 通道底层存储数据结构是环形链表
  + 浅拷贝知识拷贝值以及值中直接包含的东西，深拷贝就是把所有深层次的结构一并拷贝，值得注意的是，Go语言
    中并没有深拷贝

### 通道的高级玩法
我们常说的通道，往往指的都是双向通道，即可接收也可发送。另外还有一种通道，也就是单向通道，也就是接收和
发送操作，同时只能满足一个，这往往可以在类型字面量中体现。`<-`操作符，不仅可以表示通道的接收或发送，
同时也可以用于表示通道的方向。

    //如下代码，表示这是一个容量为1的发送通道
    var uselessChan = make(chan <- int,1)
请注意，紧挨在关键字chan右边的那个`<-`，这表示了这个通道是单向的，并且是只能发而不能收的。类似的，如果
这个操作符在chan的左边(<- chan int)，就说明该通道只能收不能发，可以简称为接收通道。需要注意的是，与发送
操作和接收操作对应，这里的“发”和“收”都是站在操作通道的代码角度来说的。

#### Q：单向通道有什么应用价值？
概括来说，单向通道最主要的用途就是约束其他代码的行为。

**问题解析**
1. 这需要从两个方面来讲，都跟函数的声明有些关系。这里先贴一段代码：

       func SendInt(ch chan <- int) {
            ch <- rand.Intn(1000)
       }
    先用func声明了一个叫做SendInt的函数。这个函数中的代码只能向参数ch发送元素值，而不能从它那里接收元素。
    这就起到了约束函数行为的作用。在实际场景中，这种约束一般会出现在接口类型声明中的某个方法定义上。顺便
    说一下，我们在调用SendInt函数的时候，只需要把一个元素类型匹配的双向通道传给它就行了，没有必要使用发送
    通道，因为Go语言在这种情况下会自动地把双向通道转换为函数所需地单向通道。
2. 在另一个方面，我们还可以在返回值中使用单向通道，并不局限于参数。形式如下：

        func getIntChan() <- chan int {
            num := 5
            ch := make(chan int,num)
            for i := 0;i < num;i++{
                ch <- i
            }
            close(ch)
            return ch
        }

#### Q：知识扩展
**问题1：select语句与通道怎样联用，应该注意些什么？**
   + select语句只能与通道联用，它一般由若干个分支组成。每次执行这种语句的时候，一般只有一个分支中的
     代码会被运行。select语句的分支分为两种，一种叫做候选分支，另一种叫做默认分支。
   + **候选分支**总是以关键字case开头，后跟一个case表达式和一个冒号，然后我们从下一行开始写入当分支
     被选中时，需要执行的代码。**默认分支**其实就是default case。
   + 由于select语句是专门为通道而设计的，所以每个case表达式中都只能包含操作通道的表达式，例如接收表示
     式。同样，这里贴一下代码：

            //准备好3个通道
            intChannels := [3]chan int {
                make(chan int,1),
                make(chan int,1),
                make(chan int,1),
            }
            //随机选择一个通道，并向它发送元素值
            index := rand.Intn(3)
            fmt.Printf("The index:%d\n",index)
            intChannels[index] <- index
            //哪一个通道中有可取的元素值，哪个对应的分支就会被执行
            select {
            case <- intChannels[0]:
                fmt.Println("The first candidate case is selected.")
            case <- intChannels[1]:
                fmt.Println("The second candidate case is selected.")
            case <- intChannels[2]:
                fmt.Println("The third candidate case is selected.")
            default:
                fmt.Println("no candidate case is selected!")
            }
   + 在使用select语句的时候，我们首先需要注意以下几个事情：
     <br/>1.如果像上述那样加入了默认分支，那么无论涉及通道操作的表达式是否有阻塞，select语句都不会
     被阻塞。如果候选分支的表达式都被阻塞了，那么默认分支就会被选中并执行。
     <br/>2.如果没有加入默认分支，那么一旦所有的case表达式都没有满足求值的条件，那么select语句就会
     被阻塞。直到至少有一个case表达式满足条件为止。
     <br/>3.还记得吗？我们可能会因为通道关闭了，而直接从通道接收到一个其元素类型的零值。所以，在很多
     时候，我们需要通过接收表达式的第二个结果值来判断通道是否已经关闭。一旦发现某个通道关闭了，我们就
     应该及时的屏蔽掉对应的分支或者采取其他措施。这对于程序逻辑和程序性能都是有好处的。
     <br/>4.select语句只能对其中的每一个case表达式各求值一次。所以，如果我们想连续或定时的操作其中的
     通道的话，就往往需要通过在for语句中嵌套select语句的方式实现。但这时要注意，简单的在select语句的
     分支中使用break，只能结束当前的select语句的执行，而并不会对外层的for语句产生作用，这种错误的用法
     可能会让这个for语句无休止的运行下去。这里贴以下代码：

         intChan := make(chan int,1)
         //一秒后关闭通道
         time.AfterFunc(time.Second,func() {
            close(intChan)
         })
         select {
         case _,ok := <- intChan:
            if !ok {
                fmt.Println("The candidate case is closed.")
                break
            }
            fmt.Println("The candidate case is selected.")
         }
     在select语句种只有一个候选分支，在其中利用接收表达式的第二个结果值对intChan通道是否已关闭做了判断，并在
     得到肯定结果后，通过break语句立即结束当前select语句的执行。

**问题2：select语句的分支选择规则有哪些？**
规则如下面所示：
1. 对于每一个case表达式，都至少包含一个代表收发操作的接收表达式，同时也可能会包含其他的表达式。比如：如果case
   表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式结果
   必须是可以被赋值的。当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。
2. select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从
   上到下的。结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是
   它右边的表达式。以此类推，直到满足退出的条件。
3. 对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表
   达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。
4. 仅当select语句中的所有case表达式都求值完毕，它才会开始选择候选分支。这时候，它只会挑选满足条件的候选分支执行，
   如果所有的候选分支都不满足选择条件，那么就会执行默认分支。如果没有默认分支，那么select就会进入阻塞状态，直到
   有一个候选分支满足条件。
5. 如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行，注意
   即使select语句是在被唤醒时发现的这种情况，也会这样做
6. 一条select语句中只能有一个默认分支
7. select语句的每次执行，包括case表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中
   的case表达式以及分支中，是否包含并发不安全的代码了
